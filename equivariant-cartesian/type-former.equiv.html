<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>type-former.equiv</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">{-

Definitions of contractibility and equivalences.

-}</a>
<a id="58" class="Keyword">module</a> <a id="65" href="type-former.equiv.html" class="Module">type-former.equiv</a> <a id="83" class="Keyword">where</a>

<a id="90" class="Keyword">open</a> <a id="95" class="Keyword">import</a> <a id="102" href="basic.html" class="Module">basic</a>
<a id="108" class="Keyword">open</a> <a id="113" class="Keyword">import</a> <a id="120" href="internal-extensional-type-theory.html" class="Module">internal-extensional-type-theory</a>
<a id="153" class="Keyword">open</a> <a id="158" class="Keyword">import</a> <a id="165" href="axiom.html" class="Module">axiom</a>
<a id="171" class="Keyword">open</a> <a id="176" class="Keyword">import</a> <a id="183" href="cofibration.html" class="Module">cofibration</a>
<a id="195" class="Keyword">open</a> <a id="200" class="Keyword">import</a> <a id="207" href="fibration.transport.html" class="Module">fibration.transport</a>
<a id="227" class="Keyword">open</a> <a id="232" class="Keyword">import</a> <a id="239" href="fibration.fibration.html" class="Module">fibration.fibration</a>
<a id="259" class="Keyword">open</a> <a id="264" class="Keyword">import</a> <a id="271" href="fibration.trivial.html" class="Module">fibration.trivial</a>
<a id="289" class="Keyword">open</a> <a id="294" class="Keyword">import</a> <a id="301" href="type-former.hlevels.html" class="Module">type-former.hlevels</a>
<a id="321" class="Keyword">open</a> <a id="326" class="Keyword">import</a> <a id="333" href="type-former.path.html" class="Module">type-former.path</a>
<a id="350" class="Keyword">open</a> <a id="355" class="Keyword">import</a> <a id="362" href="type-former.pi.html" class="Module">type-former.pi</a>
<a id="377" class="Keyword">open</a> <a id="382" class="Keyword">import</a> <a id="389" href="type-former.sigma.html" class="Module">type-former.sigma</a>

<a id="408" class="Keyword">private</a> <a id="416" class="Keyword">variable</a>
  <a id="427" href="type-former.equiv.html#427" class="Generalizable">ℓ</a> <a id="429" href="type-former.equiv.html#429" class="Generalizable">ℓ&#39;</a> <a id="432" href="type-former.equiv.html#432" class="Generalizable">ℓ&#39;&#39;</a> <a id="436" class="Symbol">:</a> <a id="438" href="Agda.Primitive.html#742" class="Postulate">Level</a>
  <a id="446" href="type-former.equiv.html#446" class="Generalizable">Γ</a> <a id="448" href="type-former.equiv.html#448" class="Generalizable">Δ</a> <a id="450" class="Symbol">:</a> <a id="452" href="basic.prelude.html#227" class="Primitive">Type</a> <a id="457" href="type-former.equiv.html#427" class="Generalizable">ℓ</a>

<a id="460" class="Keyword">infix</a> <a id="466" class="Number">4</a> <a id="468" href="type-former.equiv.html#775" class="Function Operator">_≃_</a>

<a id="473" class="Comment">------------------------------------------------------------------------------------------</a>
<a id="564" class="Comment">-- Equivalences.</a>
<a id="581" class="Comment">------------------------------------------------------------------------------------------</a>

<a id="IsEquiv"></a><a id="673" href="type-former.equiv.html#673" class="Function">IsEquiv</a> <a id="681" class="Symbol">:</a> <a id="683" class="Symbol">{</a><a id="684" href="type-former.equiv.html#684" class="Bound">A</a> <a id="686" class="Symbol">:</a> <a id="688" href="basic.prelude.html#227" class="Primitive">Type</a> <a id="693" href="type-former.equiv.html#427" class="Generalizable">ℓ</a><a id="694" class="Symbol">}</a> <a id="696" class="Symbol">{</a><a id="697" href="type-former.equiv.html#697" class="Bound">B</a> <a id="699" class="Symbol">:</a> <a id="701" href="basic.prelude.html#227" class="Primitive">Type</a> <a id="706" href="type-former.equiv.html#429" class="Generalizable">ℓ&#39;</a><a id="708" class="Symbol">}</a> <a id="710" class="Symbol">→</a> <a id="712" class="Symbol">(</a><a id="713" href="type-former.equiv.html#684" class="Bound">A</a> <a id="715" class="Symbol">→</a> <a id="717" href="type-former.equiv.html#697" class="Bound">B</a><a id="718" class="Symbol">)</a> <a id="720" class="Symbol">→</a> <a id="722" href="basic.prelude.html#227" class="Primitive">Type</a> <a id="727" class="Symbol">(</a><a id="728" href="type-former.equiv.html#427" class="Generalizable">ℓ</a> <a id="730" href="Agda.Primitive.html#961" class="Primitive Operator">⊔</a> <a id="732" href="type-former.equiv.html#429" class="Generalizable">ℓ&#39;</a><a id="734" class="Symbol">)</a>
<a id="736" href="type-former.equiv.html#673" class="Function">IsEquiv</a> <a id="744" href="type-former.equiv.html#744" class="Bound">f</a> <a id="746" class="Symbol">=</a> <a id="748" class="Symbol">∀</a> <a id="750" href="type-former.equiv.html#750" class="Bound">b</a> <a id="752" class="Symbol">→</a> <a id="754" href="type-former.hlevels.html#691" class="Function">IsContr</a> <a id="762" class="Symbol">(</a><a id="763" href="type-former.path.html#3628" class="Function">Fiber</a> <a id="769" href="type-former.equiv.html#744" class="Bound">f</a> <a id="771" href="type-former.equiv.html#750" class="Bound">b</a><a id="772" class="Symbol">)</a>

<a id="_≃_"></a><a id="775" href="type-former.equiv.html#775" class="Function Operator">_≃_</a> <a id="779" class="Symbol">:</a> <a id="781" class="Symbol">(</a><a id="782" href="type-former.equiv.html#782" class="Bound">A</a> <a id="784" class="Symbol">:</a> <a id="786" href="basic.prelude.html#227" class="Primitive">Type</a> <a id="791" href="type-former.equiv.html#427" class="Generalizable">ℓ</a><a id="792" class="Symbol">)</a> <a id="794" class="Symbol">(</a><a id="795" href="type-former.equiv.html#795" class="Bound">B</a> <a id="797" class="Symbol">:</a> <a id="799" href="basic.prelude.html#227" class="Primitive">Type</a> <a id="804" href="type-former.equiv.html#429" class="Generalizable">ℓ&#39;</a><a id="806" class="Symbol">)</a> <a id="808" class="Symbol">→</a> <a id="810" href="basic.prelude.html#227" class="Primitive">Type</a> <a id="815" class="Symbol">(</a><a id="816" href="type-former.equiv.html#427" class="Generalizable">ℓ</a> <a id="818" href="Agda.Primitive.html#961" class="Primitive Operator">⊔</a> <a id="820" href="type-former.equiv.html#429" class="Generalizable">ℓ&#39;</a><a id="822" class="Symbol">)</a>
<a id="824" href="type-former.equiv.html#824" class="Bound">A</a> <a id="826" href="type-former.equiv.html#775" class="Function Operator">≃</a> <a id="828" href="type-former.equiv.html#828" class="Bound">B</a> <a id="830" class="Symbol">=</a> <a id="832" href="basic.sigma.html#196" class="Record">Σ</a> <a id="834" class="Symbol">(</a><a id="835" href="type-former.equiv.html#824" class="Bound">A</a> <a id="837" class="Symbol">→</a> <a id="839" href="type-former.equiv.html#828" class="Bound">B</a><a id="840" class="Symbol">)</a> <a id="842" href="type-former.equiv.html#673" class="Function">IsEquiv</a>

<a id="IsEquivˣ"></a><a id="851" href="type-former.equiv.html#851" class="Function">IsEquivˣ</a> <a id="860" class="Symbol">:</a> <a id="862" class="Symbol">{</a><a id="863" href="type-former.equiv.html#863" class="Bound">A</a> <a id="865" class="Symbol">:</a> <a id="867" href="type-former.equiv.html#446" class="Generalizable">Γ</a> <a id="869" class="Symbol">→</a> <a id="871" href="basic.prelude.html#227" class="Primitive">Type</a> <a id="876" href="type-former.equiv.html#427" class="Generalizable">ℓ</a><a id="877" class="Symbol">}</a> <a id="879" class="Symbol">{</a><a id="880" href="type-former.equiv.html#880" class="Bound">B</a> <a id="882" class="Symbol">:</a> <a id="884" href="type-former.equiv.html#446" class="Generalizable">Γ</a> <a id="886" class="Symbol">→</a> <a id="888" href="basic.prelude.html#227" class="Primitive">Type</a> <a id="893" href="type-former.equiv.html#429" class="Generalizable">ℓ&#39;</a><a id="895" class="Symbol">}</a> <a id="897" class="Symbol">(</a><a id="898" href="type-former.equiv.html#898" class="Bound">f</a> <a id="900" class="Symbol">:</a> <a id="902" href="type-former.equiv.html#446" class="Generalizable">Γ</a> <a id="904" href="internal-extensional-type-theory.html#1372" class="Function Operator">⊢ˣ</a> <a id="907" href="type-former.equiv.html#863" class="Bound">A</a> <a id="909" href="internal-extensional-type-theory.html#2508" class="Function Operator">→ˣ</a> <a id="912" href="type-former.equiv.html#880" class="Bound">B</a><a id="913" class="Symbol">)</a>
  <a id="917" class="Symbol">→</a> <a id="919" href="type-former.equiv.html#446" class="Generalizable">Γ</a> <a id="921" class="Symbol">→</a> <a id="923" href="basic.prelude.html#227" class="Primitive">Type</a> <a id="928" class="Symbol">(</a><a id="929" href="type-former.equiv.html#427" class="Generalizable">ℓ</a> <a id="931" href="Agda.Primitive.html#961" class="Primitive Operator">⊔</a> <a id="933" href="type-former.equiv.html#429" class="Generalizable">ℓ&#39;</a><a id="935" class="Symbol">)</a>
<a id="937" href="type-former.equiv.html#851" class="Function">IsEquivˣ</a> <a id="946" href="type-former.equiv.html#946" class="Bound">f</a> <a id="948" class="Symbol">=</a> <a id="950" href="internal-extensional-type-theory.html#2409" class="Function">Πˣ</a> <a id="953" class="Symbol">_</a> <a id="955" class="Symbol">(</a><a id="956" href="type-former.hlevels.html#760" class="Function">IsContrˣ</a> <a id="965" class="Symbol">(</a><a id="966" href="type-former.path.html#3730" class="Function">Fiberˣ</a> <a id="973" class="Symbol">(</a><a id="974" href="type-former.equiv.html#946" class="Bound">f</a> <a id="976" href="basic.function.html#441" class="Function Operator">∘</a> <a id="978" href="internal-extensional-type-theory.html#2013" class="Function">𝒑</a><a id="979" class="Symbol">)</a> <a id="981" href="internal-extensional-type-theory.html#2153" class="Function">𝒒</a><a id="982" class="Symbol">))</a>

<a id="_≃ˣ_"></a><a id="986" href="type-former.equiv.html#986" class="Function Operator">_≃ˣ_</a> <a id="991" class="Symbol">:</a> <a id="993" class="Symbol">(</a><a id="994" href="type-former.equiv.html#994" class="Bound">A</a> <a id="996" class="Symbol">:</a> <a id="998" href="type-former.equiv.html#446" class="Generalizable">Γ</a> <a id="1000" class="Symbol">→</a> <a id="1002" href="basic.prelude.html#227" class="Primitive">Type</a> <a id="1007" href="type-former.equiv.html#427" class="Generalizable">ℓ</a><a id="1008" class="Symbol">)</a> <a id="1010" class="Symbol">(</a><a id="1011" href="type-former.equiv.html#1011" class="Bound">B</a> <a id="1013" class="Symbol">:</a> <a id="1015" href="type-former.equiv.html#446" class="Generalizable">Γ</a> <a id="1017" class="Symbol">→</a> <a id="1019" href="basic.prelude.html#227" class="Primitive">Type</a> <a id="1024" href="type-former.equiv.html#429" class="Generalizable">ℓ&#39;</a><a id="1026" class="Symbol">)</a> <a id="1028" class="Symbol">→</a> <a id="1030" class="Symbol">(</a><a id="1031" href="type-former.equiv.html#446" class="Generalizable">Γ</a> <a id="1033" class="Symbol">→</a> <a id="1035" href="basic.prelude.html#227" class="Primitive">Type</a> <a id="1040" class="Symbol">(</a><a id="1041" href="type-former.equiv.html#427" class="Generalizable">ℓ</a> <a id="1043" href="Agda.Primitive.html#961" class="Primitive Operator">⊔</a> <a id="1045" href="type-former.equiv.html#429" class="Generalizable">ℓ&#39;</a><a id="1047" class="Symbol">))</a>
<a id="1050" href="type-former.equiv.html#1050" class="Bound">A</a> <a id="1052" href="type-former.equiv.html#986" class="Function Operator">≃ˣ</a> <a id="1055" href="type-former.equiv.html#1055" class="Bound">B</a> <a id="1057" class="Symbol">=</a> <a id="1059" href="internal-extensional-type-theory.html#3015" class="Function">Σˣ</a> <a id="1062" class="Symbol">(</a><a id="1063" href="type-former.equiv.html#1050" class="Bound">A</a> <a id="1065" href="internal-extensional-type-theory.html#2508" class="Function Operator">→ˣ</a> <a id="1068" href="type-former.equiv.html#1055" class="Bound">B</a><a id="1069" class="Symbol">)</a> <a id="1071" class="Symbol">(</a><a id="1072" href="type-former.equiv.html#851" class="Function">IsEquivˣ</a> <a id="1081" href="basic.sigma.html#293" class="Field">snd</a><a id="1084" class="Symbol">)</a>

<a id="1087" class="Comment">--↓ An isomorphism composed with an equivalence is an equivalence.</a>

<a id="equiv∘iso"></a><a id="1155" href="type-former.equiv.html#1155" class="Function">equiv∘iso</a> <a id="1165" class="Symbol">:</a> <a id="1167" class="Symbol">{</a><a id="1168" href="type-former.equiv.html#1168" class="Bound">A</a> <a id="1170" class="Symbol">:</a> <a id="1172" href="basic.prelude.html#227" class="Primitive">Type</a> <a id="1177" href="type-former.equiv.html#427" class="Generalizable">ℓ</a><a id="1178" class="Symbol">}</a> <a id="1180" class="Symbol">{</a><a id="1181" href="type-former.equiv.html#1181" class="Bound">B</a> <a id="1183" class="Symbol">:</a> <a id="1185" href="basic.prelude.html#227" class="Primitive">Type</a> <a id="1190" href="type-former.equiv.html#429" class="Generalizable">ℓ&#39;</a><a id="1192" class="Symbol">}</a> <a id="1194" class="Symbol">{</a><a id="1195" href="type-former.equiv.html#1195" class="Bound">C</a> <a id="1197" class="Symbol">:</a> <a id="1199" href="basic.prelude.html#227" class="Primitive">Type</a> <a id="1204" href="type-former.equiv.html#432" class="Generalizable">ℓ&#39;&#39;</a><a id="1207" class="Symbol">}</a>
  <a id="1211" class="Symbol">→</a> <a id="1213" href="type-former.equiv.html#1168" class="Bound">A</a> <a id="1215" href="basic.isomorphism.html#272" class="Record Operator">≅</a> <a id="1217" href="type-former.equiv.html#1181" class="Bound">B</a> <a id="1219" class="Symbol">→</a> <a id="1221" href="type-former.equiv.html#1181" class="Bound">B</a> <a id="1223" href="type-former.equiv.html#775" class="Function Operator">≃</a> <a id="1225" href="type-former.equiv.html#1195" class="Bound">C</a> <a id="1227" class="Symbol">→</a> <a id="1229" href="type-former.equiv.html#1168" class="Bound">A</a> <a id="1231" href="type-former.equiv.html#775" class="Function Operator">≃</a> <a id="1233" href="type-former.equiv.html#1195" class="Bound">C</a>
<a id="1235" href="type-former.equiv.html#1155" class="Function">equiv∘iso</a> <a id="1245" href="type-former.equiv.html#1245" class="Bound">iso</a> <a id="1249" href="type-former.equiv.html#1249" class="Bound">e</a> <a id="1251" class="Symbol">.</a><a id="1252" href="basic.sigma.html#281" class="Field">fst</a> <a id="1256" class="Symbol">=</a> <a id="1258" href="type-former.equiv.html#1249" class="Bound">e</a> <a id="1260" class="Symbol">.</a><a id="1261" href="basic.sigma.html#281" class="Field">fst</a> <a id="1265" href="basic.function.html#441" class="Function Operator">∘</a> <a id="1267" href="type-former.equiv.html#1245" class="Bound">iso</a> <a id="1271" class="Symbol">.</a><a id="1272" href="basic.isomorphism.html#334" class="Field">to</a>
<a id="1275" href="type-former.equiv.html#1155" class="Function">equiv∘iso</a> <a id="1285" href="type-former.equiv.html#1285" class="Bound">iso</a> <a id="1289" href="type-former.equiv.html#1289" class="Bound">e</a> <a id="1291" class="Symbol">.</a><a id="1292" href="basic.sigma.html#293" class="Field">snd</a> <a id="1296" href="type-former.equiv.html#1296" class="Bound">c</a> <a id="1298" class="Symbol">=</a> <a id="1300" href="type-former.equiv.html#1600" class="Function">contractor</a>
  <a id="1313" class="Keyword">where</a>
  <a id="1321" href="type-former.equiv.html#1321" class="Function">invertFiber</a> <a id="1333" class="Symbol">:</a> <a id="1335" class="Symbol">∀</a> <a id="1337" href="type-former.equiv.html#1337" class="Bound">c</a> <a id="1339" class="Symbol">→</a> <a id="1341" href="type-former.path.html#3628" class="Function">Fiber</a> <a id="1347" class="Symbol">(</a><a id="1348" href="type-former.equiv.html#1289" class="Bound">e</a> <a id="1350" class="Symbol">.</a><a id="1351" href="basic.sigma.html#281" class="Field">fst</a><a id="1354" class="Symbol">)</a> <a id="1356" href="type-former.equiv.html#1337" class="Bound">c</a> <a id="1358" class="Symbol">→</a> <a id="1360" href="type-former.path.html#3628" class="Function">Fiber</a> <a id="1366" class="Symbol">(</a><a id="1367" href="type-former.equiv.html#1289" class="Bound">e</a> <a id="1369" class="Symbol">.</a><a id="1370" href="basic.sigma.html#281" class="Field">fst</a> <a id="1374" href="basic.function.html#441" class="Function Operator">∘</a> <a id="1376" href="type-former.equiv.html#1285" class="Bound">iso</a> <a id="1380" class="Symbol">.</a><a id="1381" href="basic.isomorphism.html#334" class="Field">to</a><a id="1383" class="Symbol">)</a> <a id="1385" href="type-former.equiv.html#1337" class="Bound">c</a>
  <a id="1389" href="type-former.equiv.html#1321" class="Function">invertFiber</a> <a id="1401" href="type-former.equiv.html#1401" class="Bound">c</a> <a id="1403" class="Symbol">(</a><a id="1404" href="type-former.equiv.html#1404" class="Bound">b</a> <a id="1406" href="basic.sigma.html#265" class="InductiveConstructor Operator">,</a> <a id="1408" href="type-former.equiv.html#1408" class="Bound">p</a><a id="1409" class="Symbol">)</a> <a id="1411" class="Symbol">.</a><a id="1412" href="basic.sigma.html#281" class="Field">fst</a> <a id="1416" class="Symbol">=</a> <a id="1418" href="type-former.equiv.html#1285" class="Bound">iso</a> <a id="1422" class="Symbol">.</a><a id="1423" href="basic.isomorphism.html#349" class="Field">from</a> <a id="1428" href="type-former.equiv.html#1404" class="Bound">b</a>
  <a id="1432" href="type-former.equiv.html#1321" class="Function">invertFiber</a> <a id="1444" href="type-former.equiv.html#1444" class="Bound">c</a> <a id="1446" class="Symbol">(</a><a id="1447" href="type-former.equiv.html#1447" class="Bound">b</a> <a id="1449" href="basic.sigma.html#265" class="InductiveConstructor Operator">,</a> <a id="1451" href="type-former.equiv.html#1451" class="Bound">p</a><a id="1452" class="Symbol">)</a> <a id="1454" class="Symbol">.</a><a id="1455" href="basic.sigma.html#293" class="Field">snd</a> <a id="1459" class="Symbol">.</a><a id="1460" href="type-former.path.html#550" class="Field">at</a> <a id="1463" class="Symbol">=</a> <a id="1465" href="type-former.equiv.html#1451" class="Bound">p</a> <a id="1467" class="Symbol">.</a><a id="1468" href="type-former.path.html#550" class="Field">at</a>
  <a id="1473" href="type-former.equiv.html#1321" class="Function">invertFiber</a> <a id="1485" href="type-former.equiv.html#1485" class="Bound">c</a> <a id="1487" class="Symbol">(</a><a id="1488" href="type-former.equiv.html#1488" class="Bound">b</a> <a id="1490" href="basic.sigma.html#265" class="InductiveConstructor Operator">,</a> <a id="1492" href="type-former.equiv.html#1492" class="Bound">p</a><a id="1493" class="Symbol">)</a> <a id="1495" class="Symbol">.</a><a id="1496" href="basic.sigma.html#293" class="Field">snd</a> <a id="1500" class="Symbol">.</a><a id="1501" href="type-former.path.html#565" class="Field">at0</a> <a id="1505" class="Symbol">=</a>
    <a id="1511" href="type-former.equiv.html#1492" class="Bound">p</a> <a id="1513" class="Symbol">.</a><a id="1514" href="type-former.path.html#565" class="Field">at0</a> <a id="1518" href="basic.equality.html#1002" class="Function Operator">∙</a> <a id="1520" href="basic.equality.html#1460" class="Function">cong</a> <a id="1525" class="Symbol">(</a><a id="1526" href="type-former.equiv.html#1289" class="Bound">e</a> <a id="1528" class="Symbol">.</a><a id="1529" href="basic.sigma.html#281" class="Field">fst</a><a id="1532" class="Symbol">)</a> <a id="1534" class="Symbol">(</a><a id="1535" href="basic.equality.html#1129" class="Function">sym</a> <a id="1539" class="Symbol">(</a><a id="1540" href="type-former.equiv.html#1285" class="Bound">iso</a> <a id="1544" class="Symbol">.</a><a id="1545" href="basic.isomorphism.html#395" class="Field">inv₂</a> <a id="1550" class="Symbol">_))</a>
  <a id="1556" href="type-former.equiv.html#1321" class="Function">invertFiber</a> <a id="1568" href="type-former.equiv.html#1568" class="Bound">c</a> <a id="1570" class="Symbol">(</a><a id="1571" href="type-former.equiv.html#1571" class="Bound">b</a> <a id="1573" href="basic.sigma.html#265" class="InductiveConstructor Operator">,</a> <a id="1575" href="type-former.equiv.html#1575" class="Bound">p</a><a id="1576" class="Symbol">)</a> <a id="1578" class="Symbol">.</a><a id="1579" href="basic.sigma.html#293" class="Field">snd</a> <a id="1583" class="Symbol">.</a><a id="1584" href="type-former.path.html#585" class="Field">at1</a> <a id="1588" class="Symbol">=</a> <a id="1590" href="type-former.equiv.html#1575" class="Bound">p</a> <a id="1592" class="Symbol">.</a><a id="1593" href="type-former.path.html#585" class="Field">at1</a>

  <a id="1600" href="type-former.equiv.html#1600" class="Function">contractor</a> <a id="1611" class="Symbol">:</a> <a id="1613" href="type-former.hlevels.html#691" class="Function">IsContr</a> <a id="1621" class="Symbol">(</a><a id="1622" href="type-former.path.html#3628" class="Function">Fiber</a> <a id="1628" class="Symbol">(</a><a id="1629" href="type-former.equiv.html#1289" class="Bound">e</a> <a id="1631" class="Symbol">.</a><a id="1632" href="basic.sigma.html#281" class="Field">fst</a> <a id="1636" href="basic.function.html#441" class="Function Operator">∘</a> <a id="1638" href="type-former.equiv.html#1285" class="Bound">iso</a> <a id="1642" class="Symbol">.</a><a id="1643" href="basic.isomorphism.html#334" class="Field">to</a><a id="1645" class="Symbol">)</a> <a id="1647" href="type-former.equiv.html#1296" class="Bound">c</a><a id="1648" class="Symbol">)</a>
  <a id="1652" href="type-former.equiv.html#1600" class="Function">contractor</a> <a id="1663" class="Symbol">.</a><a id="1664" href="basic.sigma.html#281" class="Field">fst</a> <a id="1668" class="Symbol">=</a> <a id="1670" href="type-former.equiv.html#1321" class="Function">invertFiber</a> <a id="1682" href="type-former.equiv.html#1296" class="Bound">c</a> <a id="1684" class="Symbol">(</a><a id="1685" href="type-former.equiv.html#1289" class="Bound">e</a> <a id="1687" class="Symbol">.</a><a id="1688" href="basic.sigma.html#293" class="Field">snd</a> <a id="1692" href="type-former.equiv.html#1296" class="Bound">c</a> <a id="1694" class="Symbol">.</a><a id="1695" href="basic.sigma.html#281" class="Field">fst</a><a id="1698" class="Symbol">)</a>
  <a id="1702" href="type-former.equiv.html#1600" class="Function">contractor</a> <a id="1713" class="Symbol">.</a><a id="1714" href="basic.sigma.html#293" class="Field">snd</a> <a id="1718" class="Symbol">(</a><a id="1719" href="type-former.equiv.html#1719" class="Bound">a</a> <a id="1721" href="basic.sigma.html#265" class="InductiveConstructor Operator">,</a> <a id="1723" href="type-former.equiv.html#1723" class="Bound">p</a><a id="1724" class="Symbol">)</a> <a id="1726" class="Symbol">=</a>
    <a id="1732" href="basic.equality.html#1232" class="Function">subst</a>
      <a id="1744" class="Symbol">(_</a> <a id="1747" href="type-former.path.html#475" class="Record Operator">~_</a><a id="1749" class="Symbol">)</a>
      <a id="1757" class="Symbol">(</a><a id="1758" href="type-former.path.html#4658" class="Function">FiberExt</a> <a id="1767" class="Symbol">(</a><a id="1768" href="type-former.equiv.html#1285" class="Bound">iso</a> <a id="1772" class="Symbol">.</a><a id="1773" href="basic.isomorphism.html#364" class="Field">inv₁</a> <a id="1778" class="Symbol">_)</a> <a id="1781" class="Symbol">(λ</a> <a id="1784" href="type-former.equiv.html#1784" class="Bound">_</a> <a id="1786" class="Symbol">→</a> <a id="1788" href="basic.prelude.html#302" class="InductiveConstructor">refl</a><a id="1792" class="Symbol">))</a>
      <a id="1801" class="Symbol">(</a><a id="1802" href="type-former.path.html#834" class="Function">congPath</a>
        <a id="1819" class="Symbol">(</a><a id="1820" href="type-former.equiv.html#1321" class="Function">invertFiber</a> <a id="1832" href="type-former.equiv.html#1296" class="Bound">c</a><a id="1833" class="Symbol">)</a>
        <a id="1843" class="Symbol">(</a><a id="1844" href="type-former.equiv.html#1289" class="Bound">e</a> <a id="1846" class="Symbol">.</a><a id="1847" href="basic.sigma.html#293" class="Field">snd</a> <a id="1851" href="type-former.equiv.html#1296" class="Bound">c</a> <a id="1853" class="Symbol">.</a><a id="1854" href="basic.sigma.html#293" class="Field">snd</a> <a id="1858" class="Symbol">(</a><a id="1859" href="type-former.equiv.html#1285" class="Bound">iso</a> <a id="1863" class="Symbol">.</a><a id="1864" href="basic.isomorphism.html#334" class="Field">to</a> <a id="1867" href="type-former.equiv.html#1719" class="Bound">a</a> <a id="1869" href="basic.sigma.html#265" class="InductiveConstructor Operator">,</a> <a id="1871" href="type-former.equiv.html#1723" class="Bound">p</a><a id="1872" class="Symbol">)))</a>

<a id="1877" class="Comment">------------------------------------------------------------------------------------------</a>
<a id="1968" class="Comment">-- Fibrancy of the type of equivalences between two fibrant types.</a>
<a id="2035" class="Comment">------------------------------------------------------------------------------------------</a>

<a id="2127" class="Keyword">opaque</a>
  <a id="IsEquivFibStr"></a><a id="2136" href="type-former.equiv.html#2136" class="Function">IsEquivFibStr</a> <a id="2150" class="Symbol">:</a> <a id="2152" class="Symbol">{</a><a id="2153" href="type-former.equiv.html#2153" class="Bound">A</a> <a id="2155" class="Symbol">:</a> <a id="2157" href="type-former.equiv.html#446" class="Generalizable">Γ</a> <a id="2159" class="Symbol">→</a> <a id="2161" href="basic.prelude.html#227" class="Primitive">Type</a> <a id="2166" href="type-former.equiv.html#427" class="Generalizable">ℓ</a><a id="2167" class="Symbol">}</a> <a id="2169" class="Symbol">(</a><a id="2170" href="type-former.equiv.html#2170" class="Bound">α</a> <a id="2172" class="Symbol">:</a> <a id="2174" href="fibration.fibration.html#7152" class="Record">FibStr</a> <a id="2181" href="type-former.equiv.html#2153" class="Bound">A</a><a id="2182" class="Symbol">)</a> <a id="2184" class="Symbol">{</a><a id="2185" href="type-former.equiv.html#2185" class="Bound">B</a> <a id="2187" class="Symbol">:</a> <a id="2189" href="type-former.equiv.html#446" class="Generalizable">Γ</a> <a id="2191" class="Symbol">→</a> <a id="2193" href="basic.prelude.html#227" class="Primitive">Type</a> <a id="2198" href="type-former.equiv.html#429" class="Generalizable">ℓ&#39;</a><a id="2200" class="Symbol">}</a> <a id="2202" class="Symbol">(</a><a id="2203" href="type-former.equiv.html#2203" class="Bound">β</a> <a id="2205" class="Symbol">:</a> <a id="2207" href="fibration.fibration.html#7152" class="Record">FibStr</a> <a id="2214" href="type-former.equiv.html#2185" class="Bound">B</a><a id="2215" class="Symbol">)</a>
    <a id="2221" class="Symbol">(</a><a id="2222" href="type-former.equiv.html#2222" class="Bound">f</a> <a id="2224" class="Symbol">:</a> <a id="2226" href="type-former.equiv.html#446" class="Generalizable">Γ</a> <a id="2228" href="internal-extensional-type-theory.html#1372" class="Function Operator">⊢ˣ</a> <a id="2231" href="type-former.equiv.html#2153" class="Bound">A</a> <a id="2233" href="internal-extensional-type-theory.html#2508" class="Function Operator">→ˣ</a> <a id="2236" href="type-former.equiv.html#2185" class="Bound">B</a><a id="2237" class="Symbol">)</a> <a id="2239" class="Symbol">→</a> <a id="2241" href="fibration.fibration.html#7152" class="Record">FibStr</a> <a id="2248" class="Symbol">(</a><a id="2249" href="type-former.equiv.html#851" class="Function">IsEquivˣ</a> <a id="2258" href="type-former.equiv.html#2222" class="Bound">f</a><a id="2259" class="Symbol">)</a>
  <a id="2263" href="type-former.equiv.html#2136" class="Function">IsEquivFibStr</a> <a id="2277" href="type-former.equiv.html#2277" class="Bound">α</a> <a id="2279" href="type-former.equiv.html#2279" class="Bound">β</a> <a id="2281" href="type-former.equiv.html#2281" class="Bound">f</a> <a id="2283" class="Symbol">=</a>
    <a id="2289" href="type-former.pi.html#2407" class="Function">ΠFibStr</a> <a id="2297" href="type-former.equiv.html#2279" class="Bound">β</a> <a id="2299" class="Symbol">(</a><a id="2300" href="type-former.hlevels.html#870" class="Function">IsContrFibStr</a> <a id="2314" class="Symbol">(</a><a id="2315" href="type-former.path.html#3872" class="Function">FiberFibStr</a> <a id="2327" class="Symbol">(</a><a id="2328" href="type-former.equiv.html#2277" class="Bound">α</a> <a id="2330" href="fibration.fibration.html#8536" class="Function Operator">∘ᶠˢ</a> <a id="2334" href="internal-extensional-type-theory.html#2013" class="Function">𝒑</a><a id="2335" class="Symbol">)</a> <a id="2337" class="Symbol">(</a><a id="2338" href="type-former.equiv.html#2279" class="Bound">β</a> <a id="2340" href="fibration.fibration.html#8536" class="Function Operator">∘ᶠˢ</a> <a id="2344" href="internal-extensional-type-theory.html#2013" class="Function">𝒑</a><a id="2345" class="Symbol">)</a> <a id="2347" class="Symbol">(</a><a id="2348" href="type-former.equiv.html#2281" class="Bound">f</a> <a id="2350" href="basic.function.html#441" class="Function Operator">∘</a> <a id="2352" href="internal-extensional-type-theory.html#2013" class="Function">𝒑</a><a id="2353" class="Symbol">)</a> <a id="2355" href="internal-extensional-type-theory.html#2153" class="Function">𝒒</a><a id="2356" class="Symbol">))</a>

  <a id="reindexIsEquivFibStr"></a><a id="2362" href="type-former.equiv.html#2362" class="Function">reindexIsEquivFibStr</a> <a id="2383" class="Symbol">:</a> <a id="2385" class="Symbol">{</a><a id="2386" href="type-former.equiv.html#2386" class="Bound">A</a> <a id="2388" class="Symbol">:</a> <a id="2390" href="type-former.equiv.html#446" class="Generalizable">Γ</a> <a id="2392" class="Symbol">→</a> <a id="2394" href="basic.prelude.html#227" class="Primitive">Type</a> <a id="2399" href="type-former.equiv.html#427" class="Generalizable">ℓ</a><a id="2400" class="Symbol">}</a> <a id="2402" class="Symbol">{</a><a id="2403" href="type-former.equiv.html#2403" class="Bound">α</a> <a id="2405" class="Symbol">:</a> <a id="2407" href="fibration.fibration.html#7152" class="Record">FibStr</a> <a id="2414" href="type-former.equiv.html#2386" class="Bound">A</a><a id="2415" class="Symbol">}</a> <a id="2417" class="Symbol">{</a><a id="2418" href="type-former.equiv.html#2418" class="Bound">B</a> <a id="2420" class="Symbol">:</a> <a id="2422" href="type-former.equiv.html#446" class="Generalizable">Γ</a> <a id="2424" class="Symbol">→</a> <a id="2426" href="basic.prelude.html#227" class="Primitive">Type</a> <a id="2431" href="type-former.equiv.html#429" class="Generalizable">ℓ&#39;</a><a id="2433" class="Symbol">}</a> <a id="2435" class="Symbol">{</a><a id="2436" href="type-former.equiv.html#2436" class="Bound">β</a> <a id="2438" class="Symbol">:</a> <a id="2440" href="fibration.fibration.html#7152" class="Record">FibStr</a> <a id="2447" href="type-former.equiv.html#2418" class="Bound">B</a><a id="2448" class="Symbol">}</a>
    <a id="2454" class="Symbol">{</a><a id="2455" href="type-former.equiv.html#2455" class="Bound">f</a> <a id="2457" class="Symbol">:</a> <a id="2459" href="type-former.equiv.html#446" class="Generalizable">Γ</a> <a id="2461" href="internal-extensional-type-theory.html#1372" class="Function Operator">⊢ˣ</a> <a id="2464" href="type-former.equiv.html#2386" class="Bound">A</a> <a id="2466" href="internal-extensional-type-theory.html#2508" class="Function Operator">→ˣ</a> <a id="2469" href="type-former.equiv.html#2418" class="Bound">B</a><a id="2470" class="Symbol">}</a>
    <a id="2476" class="Symbol">(</a><a id="2477" href="type-former.equiv.html#2477" class="Bound">ρ</a> <a id="2479" class="Symbol">:</a> <a id="2481" href="type-former.equiv.html#448" class="Generalizable">Δ</a> <a id="2483" class="Symbol">→</a> <a id="2485" href="type-former.equiv.html#446" class="Generalizable">Γ</a><a id="2486" class="Symbol">)</a>
    <a id="2492" class="Symbol">→</a> <a id="2494" href="type-former.equiv.html#2136" class="Function">IsEquivFibStr</a> <a id="2508" href="type-former.equiv.html#2403" class="Bound">α</a> <a id="2510" href="type-former.equiv.html#2436" class="Bound">β</a> <a id="2512" href="type-former.equiv.html#2455" class="Bound">f</a> <a id="2514" href="fibration.fibration.html#8536" class="Function Operator">∘ᶠˢ</a> <a id="2518" href="type-former.equiv.html#2477" class="Bound">ρ</a> <a id="2520" href="basic.prelude.html#239" class="Datatype Operator">≡</a> <a id="2522" href="type-former.equiv.html#2136" class="Function">IsEquivFibStr</a> <a id="2536" class="Symbol">(</a><a id="2537" href="type-former.equiv.html#2403" class="Bound">α</a> <a id="2539" href="fibration.fibration.html#8536" class="Function Operator">∘ᶠˢ</a> <a id="2543" href="type-former.equiv.html#2477" class="Bound">ρ</a><a id="2544" class="Symbol">)</a> <a id="2546" class="Symbol">(</a><a id="2547" href="type-former.equiv.html#2436" class="Bound">β</a> <a id="2549" href="fibration.fibration.html#8536" class="Function Operator">∘ᶠˢ</a> <a id="2553" href="type-former.equiv.html#2477" class="Bound">ρ</a><a id="2554" class="Symbol">)</a> <a id="2556" class="Symbol">(</a><a id="2557" href="type-former.equiv.html#2455" class="Bound">f</a> <a id="2559" href="basic.function.html#441" class="Function Operator">∘</a> <a id="2561" href="type-former.equiv.html#2477" class="Bound">ρ</a><a id="2562" class="Symbol">)</a>
  <a id="2566" href="type-former.equiv.html#2362" class="Function">reindexIsEquivFibStr</a> <a id="2587" href="type-former.equiv.html#2587" class="Bound">ρ</a> <a id="2589" class="Symbol">=</a>
    <a id="2595" href="type-former.pi.html#3000" class="Function">reindexΠFibStr</a> <a id="2610" class="Symbol">_</a>
    <a id="2616" href="basic.equality.html#1002" class="Function Operator">∙</a> <a id="2618" href="basic.equality.html#1460" class="Function">cong</a> <a id="2623" class="Symbol">(</a><a id="2624" href="type-former.pi.html#2407" class="Function">ΠFibStr</a> <a id="2632" class="Symbol">_)</a>
        <a id="2643" class="Symbol">(</a><a id="2644" href="type-former.hlevels.html#1037" class="Function">reindexIsContrFibStr</a> <a id="2665" class="Symbol">_</a>
          <a id="2677" href="basic.equality.html#1002" class="Function Operator">∙</a> <a id="2679" href="basic.equality.html#1460" class="Function">cong</a> <a id="2684" href="type-former.hlevels.html#870" class="Function">IsContrFibStr</a> <a id="2698" class="Symbol">(</a><a id="2699" href="type-former.path.html#4096" class="Function">reindexFiberFibStr</a> <a id="2718" class="Symbol">_))</a>

<a id="IsEquivᶠ"></a><a id="2723" href="type-former.equiv.html#2723" class="Function">IsEquivᶠ</a> <a id="2732" class="Symbol">:</a> <a id="2734" class="Symbol">(</a><a id="2735" href="type-former.equiv.html#2735" class="Bound">A</a> <a id="2737" class="Symbol">:</a> <a id="2739" href="type-former.equiv.html#446" class="Generalizable">Γ</a> <a id="2741" href="fibration.fibration.html#7526" class="Function Operator">⊢ᶠType</a> <a id="2748" href="type-former.equiv.html#427" class="Generalizable">ℓ</a><a id="2749" class="Symbol">)</a> <a id="2751" class="Symbol">(</a><a id="2752" href="type-former.equiv.html#2752" class="Bound">B</a> <a id="2754" class="Symbol">:</a> <a id="2756" href="type-former.equiv.html#446" class="Generalizable">Γ</a> <a id="2758" href="fibration.fibration.html#7526" class="Function Operator">⊢ᶠType</a> <a id="2765" href="type-former.equiv.html#429" class="Generalizable">ℓ&#39;</a><a id="2767" class="Symbol">)</a> <a id="2769" class="Symbol">(</a><a id="2770" href="type-former.equiv.html#2770" class="Bound">f</a> <a id="2772" class="Symbol">:</a> <a id="2774" href="type-former.equiv.html#446" class="Generalizable">Γ</a> <a id="2776" href="fibration.fibration.html#8007" class="Function Operator">⊢ᶠ</a> <a id="2779" href="type-former.equiv.html#2735" class="Bound">A</a> <a id="2781" href="type-former.pi.html#2817" class="Function Operator">→ᶠ</a> <a id="2784" href="type-former.equiv.html#2752" class="Bound">B</a><a id="2785" class="Symbol">)</a>
  <a id="2789" class="Symbol">→</a> <a id="2791" href="type-former.equiv.html#446" class="Generalizable">Γ</a> <a id="2793" href="fibration.fibration.html#7526" class="Function Operator">⊢ᶠType</a> <a id="2800" class="Symbol">(</a><a id="2801" href="type-former.equiv.html#427" class="Generalizable">ℓ</a> <a id="2803" href="Agda.Primitive.html#961" class="Primitive Operator">⊔</a> <a id="2805" href="type-former.equiv.html#429" class="Generalizable">ℓ&#39;</a><a id="2807" class="Symbol">)</a>
<a id="2809" href="type-former.equiv.html#2723" class="Function">IsEquivᶠ</a> <a id="2818" href="type-former.equiv.html#2818" class="Bound">A</a> <a id="2820" href="type-former.equiv.html#2820" class="Bound">B</a> <a id="2822" href="type-former.equiv.html#2822" class="Bound">f</a> <a id="2824" class="Symbol">.</a><a id="2825" href="basic.sigma.html#281" class="Field">fst</a> <a id="2829" class="Symbol">=</a> <a id="2831" href="type-former.equiv.html#851" class="Function">IsEquivˣ</a> <a id="2840" href="type-former.equiv.html#2822" class="Bound">f</a>
<a id="2842" href="type-former.equiv.html#2723" class="Function">IsEquivᶠ</a> <a id="2851" href="type-former.equiv.html#2851" class="Bound">A</a> <a id="2853" href="type-former.equiv.html#2853" class="Bound">B</a> <a id="2855" href="type-former.equiv.html#2855" class="Bound">f</a> <a id="2857" class="Symbol">.</a><a id="2858" href="basic.sigma.html#293" class="Field">snd</a> <a id="2862" class="Symbol">=</a> <a id="2864" href="type-former.equiv.html#2136" class="Function">IsEquivFibStr</a> <a id="2878" class="Symbol">(</a><a id="2879" href="type-former.equiv.html#2851" class="Bound">A</a> <a id="2881" class="Symbol">.</a><a id="2882" href="basic.sigma.html#293" class="Field">snd</a><a id="2885" class="Symbol">)</a> <a id="2887" class="Symbol">(</a><a id="2888" href="type-former.equiv.html#2853" class="Bound">B</a> <a id="2890" class="Symbol">.</a><a id="2891" href="basic.sigma.html#293" class="Field">snd</a><a id="2894" class="Symbol">)</a> <a id="2896" href="type-former.equiv.html#2855" class="Bound">f</a>

<a id="2899" class="Keyword">opaque</a>
  <a id="EquivFibStr"></a><a id="2908" href="type-former.equiv.html#2908" class="Function">EquivFibStr</a> <a id="2920" class="Symbol">:</a> <a id="2922" class="Symbol">{</a><a id="2923" href="type-former.equiv.html#2923" class="Bound">A</a> <a id="2925" class="Symbol">:</a> <a id="2927" href="type-former.equiv.html#446" class="Generalizable">Γ</a> <a id="2929" class="Symbol">→</a> <a id="2931" href="basic.prelude.html#227" class="Primitive">Type</a> <a id="2936" href="type-former.equiv.html#427" class="Generalizable">ℓ</a><a id="2937" class="Symbol">}</a> <a id="2939" class="Symbol">(</a><a id="2940" href="type-former.equiv.html#2940" class="Bound">α</a> <a id="2942" class="Symbol">:</a> <a id="2944" href="fibration.fibration.html#7152" class="Record">FibStr</a> <a id="2951" href="type-former.equiv.html#2923" class="Bound">A</a><a id="2952" class="Symbol">)</a> <a id="2954" class="Symbol">{</a><a id="2955" href="type-former.equiv.html#2955" class="Bound">B</a> <a id="2957" class="Symbol">:</a> <a id="2959" href="type-former.equiv.html#446" class="Generalizable">Γ</a> <a id="2961" class="Symbol">→</a> <a id="2963" href="basic.prelude.html#227" class="Primitive">Type</a> <a id="2968" href="type-former.equiv.html#429" class="Generalizable">ℓ&#39;</a><a id="2970" class="Symbol">}</a> <a id="2972" class="Symbol">(</a><a id="2973" href="type-former.equiv.html#2973" class="Bound">β</a> <a id="2975" class="Symbol">:</a> <a id="2977" href="fibration.fibration.html#7152" class="Record">FibStr</a> <a id="2984" href="type-former.equiv.html#2955" class="Bound">B</a><a id="2985" class="Symbol">)</a>
    <a id="2991" class="Symbol">→</a> <a id="2993" href="fibration.fibration.html#7152" class="Record">FibStr</a> <a id="3000" class="Symbol">(</a><a id="3001" href="type-former.equiv.html#2923" class="Bound">A</a> <a id="3003" href="type-former.equiv.html#986" class="Function Operator">≃ˣ</a> <a id="3006" href="type-former.equiv.html#2955" class="Bound">B</a><a id="3007" class="Symbol">)</a>
  <a id="3011" href="type-former.equiv.html#2908" class="Function">EquivFibStr</a> <a id="3023" href="type-former.equiv.html#3023" class="Bound">α</a> <a id="3025" href="type-former.equiv.html#3025" class="Bound">β</a> <a id="3027" class="Symbol">=</a>
    <a id="3033" href="type-former.sigma.html#2578" class="Function">ΣFibStr</a> <a id="3041" class="Symbol">(</a><a id="3042" href="type-former.pi.html#2407" class="Function">ΠFibStr</a> <a id="3050" href="type-former.equiv.html#3023" class="Bound">α</a> <a id="3052" class="Symbol">(</a><a id="3053" href="type-former.equiv.html#3025" class="Bound">β</a> <a id="3055" href="fibration.fibration.html#8536" class="Function Operator">∘ᶠˢ</a> <a id="3059" href="internal-extensional-type-theory.html#2013" class="Function">𝒑</a><a id="3060" class="Symbol">))</a> <a id="3063" class="Symbol">(</a><a id="3064" href="type-former.equiv.html#2136" class="Function">IsEquivFibStr</a> <a id="3078" class="Symbol">(</a><a id="3079" href="type-former.equiv.html#3023" class="Bound">α</a> <a id="3081" href="fibration.fibration.html#8536" class="Function Operator">∘ᶠˢ</a> <a id="3085" href="internal-extensional-type-theory.html#2013" class="Function">𝒑</a><a id="3086" class="Symbol">)</a> <a id="3088" class="Symbol">(</a><a id="3089" href="type-former.equiv.html#3025" class="Bound">β</a> <a id="3091" href="fibration.fibration.html#8536" class="Function Operator">∘ᶠˢ</a> <a id="3095" href="internal-extensional-type-theory.html#2013" class="Function">𝒑</a><a id="3096" class="Symbol">)</a> <a id="3098" href="internal-extensional-type-theory.html#2153" class="Function">𝒒</a><a id="3099" class="Symbol">)</a>

  <a id="reindexEquivFibStr"></a><a id="3104" href="type-former.equiv.html#3104" class="Function">reindexEquivFibStr</a> <a id="3123" class="Symbol">:</a> <a id="3125" class="Symbol">{</a><a id="3126" href="type-former.equiv.html#3126" class="Bound">A</a> <a id="3128" class="Symbol">:</a> <a id="3130" href="type-former.equiv.html#446" class="Generalizable">Γ</a> <a id="3132" class="Symbol">→</a> <a id="3134" href="basic.prelude.html#227" class="Primitive">Type</a> <a id="3139" href="type-former.equiv.html#427" class="Generalizable">ℓ</a><a id="3140" class="Symbol">}</a> <a id="3142" class="Symbol">{</a><a id="3143" href="type-former.equiv.html#3143" class="Bound">α</a> <a id="3145" class="Symbol">:</a> <a id="3147" href="fibration.fibration.html#7152" class="Record">FibStr</a> <a id="3154" href="type-former.equiv.html#3126" class="Bound">A</a><a id="3155" class="Symbol">}</a> <a id="3157" class="Symbol">{</a><a id="3158" href="type-former.equiv.html#3158" class="Bound">B</a> <a id="3160" class="Symbol">:</a> <a id="3162" href="type-former.equiv.html#446" class="Generalizable">Γ</a> <a id="3164" class="Symbol">→</a> <a id="3166" href="basic.prelude.html#227" class="Primitive">Type</a> <a id="3171" href="type-former.equiv.html#429" class="Generalizable">ℓ&#39;</a><a id="3173" class="Symbol">}</a> <a id="3175" class="Symbol">{</a><a id="3176" href="type-former.equiv.html#3176" class="Bound">β</a> <a id="3178" class="Symbol">:</a> <a id="3180" href="fibration.fibration.html#7152" class="Record">FibStr</a> <a id="3187" href="type-former.equiv.html#3158" class="Bound">B</a><a id="3188" class="Symbol">}</a>
    <a id="3194" class="Symbol">(</a><a id="3195" href="type-former.equiv.html#3195" class="Bound">ρ</a> <a id="3197" class="Symbol">:</a> <a id="3199" href="type-former.equiv.html#448" class="Generalizable">Δ</a> <a id="3201" class="Symbol">→</a> <a id="3203" href="type-former.equiv.html#446" class="Generalizable">Γ</a><a id="3204" class="Symbol">)</a> <a id="3206" class="Symbol">→</a> <a id="3208" href="type-former.equiv.html#2908" class="Function">EquivFibStr</a> <a id="3220" href="type-former.equiv.html#3143" class="Bound">α</a> <a id="3222" href="type-former.equiv.html#3176" class="Bound">β</a> <a id="3224" href="fibration.fibration.html#8536" class="Function Operator">∘ᶠˢ</a> <a id="3228" href="type-former.equiv.html#3195" class="Bound">ρ</a> <a id="3230" href="basic.prelude.html#239" class="Datatype Operator">≡</a> <a id="3232" href="type-former.equiv.html#2908" class="Function">EquivFibStr</a> <a id="3244" class="Symbol">(</a><a id="3245" href="type-former.equiv.html#3143" class="Bound">α</a> <a id="3247" href="fibration.fibration.html#8536" class="Function Operator">∘ᶠˢ</a> <a id="3251" href="type-former.equiv.html#3195" class="Bound">ρ</a><a id="3252" class="Symbol">)</a> <a id="3254" class="Symbol">(</a><a id="3255" href="type-former.equiv.html#3176" class="Bound">β</a> <a id="3257" href="fibration.fibration.html#8536" class="Function Operator">∘ᶠˢ</a> <a id="3261" href="type-former.equiv.html#3195" class="Bound">ρ</a><a id="3262" class="Symbol">)</a>
  <a id="3266" href="type-former.equiv.html#3104" class="Function">reindexEquivFibStr</a> <a id="3285" href="type-former.equiv.html#3285" class="Bound">ρ</a> <a id="3287" class="Symbol">=</a>
    <a id="3293" href="type-former.sigma.html#2888" class="Function">reindexΣFibStr</a> <a id="3308" class="Symbol">_</a>
    <a id="3314" href="basic.equality.html#1002" class="Function Operator">∙</a> <a id="3316" href="basic.equality.html#1610" class="Function">cong₂</a> <a id="3322" class="Symbol">(λ</a> <a id="3325" href="type-former.equiv.html#3325" class="Bound">α</a> <a id="3327" href="type-former.equiv.html#3327" class="Bound">β</a> <a id="3329" class="Symbol">→</a> <a id="3331" href="type-former.sigma.html#2578" class="Function">ΣFibStr</a> <a id="3339" href="type-former.equiv.html#3325" class="Bound">α</a> <a id="3341" href="type-former.equiv.html#3327" class="Bound">β</a><a id="3342" class="Symbol">)</a> <a id="3344" class="Symbol">(</a><a id="3345" href="type-former.pi.html#3000" class="Function">reindexΠFibStr</a> <a id="3360" class="Symbol">_)</a> <a id="3363" class="Symbol">(</a><a id="3364" href="type-former.equiv.html#2362" class="Function">reindexIsEquivFibStr</a> <a id="3385" class="Symbol">_)</a>

<a id="_≃ᶠ_"></a><a id="3389" href="type-former.equiv.html#3389" class="Function Operator">_≃ᶠ_</a> <a id="3394" class="Symbol">:</a> <a id="3396" class="Symbol">(</a><a id="3397" href="type-former.equiv.html#3397" class="Bound">A</a> <a id="3399" class="Symbol">:</a> <a id="3401" href="type-former.equiv.html#446" class="Generalizable">Γ</a> <a id="3403" href="fibration.fibration.html#7526" class="Function Operator">⊢ᶠType</a> <a id="3410" href="type-former.equiv.html#427" class="Generalizable">ℓ</a><a id="3411" class="Symbol">)</a> <a id="3413" class="Symbol">(</a><a id="3414" href="type-former.equiv.html#3414" class="Bound">B</a> <a id="3416" class="Symbol">:</a> <a id="3418" href="type-former.equiv.html#446" class="Generalizable">Γ</a> <a id="3420" href="fibration.fibration.html#7526" class="Function Operator">⊢ᶠType</a> <a id="3427" href="type-former.equiv.html#429" class="Generalizable">ℓ&#39;</a><a id="3429" class="Symbol">)</a> <a id="3431" class="Symbol">→</a> <a id="3433" href="type-former.equiv.html#446" class="Generalizable">Γ</a> <a id="3435" href="fibration.fibration.html#7526" class="Function Operator">⊢ᶠType</a> <a id="3442" class="Symbol">(</a><a id="3443" href="type-former.equiv.html#427" class="Generalizable">ℓ</a> <a id="3445" href="Agda.Primitive.html#961" class="Primitive Operator">⊔</a> <a id="3447" href="type-former.equiv.html#429" class="Generalizable">ℓ&#39;</a><a id="3449" class="Symbol">)</a>
<a id="3451" class="Symbol">(</a><a id="3452" href="type-former.equiv.html#3452" class="Bound">A</a> <a id="3454" href="type-former.equiv.html#3389" class="Function Operator">≃ᶠ</a> <a id="3457" href="type-former.equiv.html#3457" class="Bound">B</a><a id="3458" class="Symbol">)</a> <a id="3460" class="Symbol">.</a><a id="3461" href="basic.sigma.html#281" class="Field">fst</a> <a id="3465" class="Symbol">=</a> <a id="3467" class="Symbol">(</a><a id="3468" href="type-former.equiv.html#3452" class="Bound">A</a> <a id="3470" class="Symbol">.</a><a id="3471" href="basic.sigma.html#281" class="Field">fst</a><a id="3474" class="Symbol">)</a> <a id="3476" href="type-former.equiv.html#986" class="Function Operator">≃ˣ</a> <a id="3479" class="Symbol">(</a><a id="3480" href="type-former.equiv.html#3457" class="Bound">B</a> <a id="3482" class="Symbol">.</a><a id="3483" href="basic.sigma.html#281" class="Field">fst</a><a id="3486" class="Symbol">)</a>
<a id="3488" class="Symbol">(</a><a id="3489" href="type-former.equiv.html#3489" class="Bound">A</a> <a id="3491" href="type-former.equiv.html#3389" class="Function Operator">≃ᶠ</a> <a id="3494" href="type-former.equiv.html#3494" class="Bound">B</a><a id="3495" class="Symbol">)</a> <a id="3497" class="Symbol">.</a><a id="3498" href="basic.sigma.html#293" class="Field">snd</a> <a id="3502" class="Symbol">=</a> <a id="3504" href="type-former.equiv.html#2908" class="Function">EquivFibStr</a> <a id="3516" class="Symbol">(</a><a id="3517" href="type-former.equiv.html#3489" class="Bound">A</a> <a id="3519" class="Symbol">.</a><a id="3520" href="basic.sigma.html#293" class="Field">snd</a><a id="3523" class="Symbol">)</a> <a id="3525" class="Symbol">(</a><a id="3526" href="type-former.equiv.html#3494" class="Bound">B</a> <a id="3528" class="Symbol">.</a><a id="3529" href="basic.sigma.html#293" class="Field">snd</a><a id="3532" class="Symbol">)</a>

<a id="reindexEquivᶠ"></a><a id="3535" href="type-former.equiv.html#3535" class="Function">reindexEquivᶠ</a> <a id="3549" class="Symbol">:</a> <a id="3551" class="Symbol">{</a><a id="3552" href="type-former.equiv.html#3552" class="Bound">A</a> <a id="3554" class="Symbol">:</a> <a id="3556" href="type-former.equiv.html#446" class="Generalizable">Γ</a> <a id="3558" href="fibration.fibration.html#7526" class="Function Operator">⊢ᶠType</a> <a id="3565" href="type-former.equiv.html#427" class="Generalizable">ℓ</a><a id="3566" class="Symbol">}</a> <a id="3568" class="Symbol">{</a><a id="3569" href="type-former.equiv.html#3569" class="Bound">B</a> <a id="3571" class="Symbol">:</a> <a id="3573" href="type-former.equiv.html#446" class="Generalizable">Γ</a> <a id="3575" href="fibration.fibration.html#7526" class="Function Operator">⊢ᶠType</a> <a id="3582" href="type-former.equiv.html#429" class="Generalizable">ℓ&#39;</a><a id="3584" class="Symbol">}</a>
  <a id="3588" class="Symbol">(</a><a id="3589" href="type-former.equiv.html#3589" class="Bound">ρ</a> <a id="3591" class="Symbol">:</a> <a id="3593" href="type-former.equiv.html#448" class="Generalizable">Δ</a> <a id="3595" class="Symbol">→</a> <a id="3597" href="type-former.equiv.html#446" class="Generalizable">Γ</a><a id="3598" class="Symbol">)</a> <a id="3600" class="Symbol">→</a> <a id="3602" class="Symbol">(</a><a id="3603" href="type-former.equiv.html#3552" class="Bound">A</a> <a id="3605" href="type-former.equiv.html#3389" class="Function Operator">≃ᶠ</a> <a id="3608" href="type-former.equiv.html#3569" class="Bound">B</a><a id="3609" class="Symbol">)</a> <a id="3611" href="fibration.fibration.html#8733" class="Function Operator">∘ᶠ</a> <a id="3614" href="type-former.equiv.html#3589" class="Bound">ρ</a> <a id="3616" href="basic.prelude.html#239" class="Datatype Operator">≡</a> <a id="3618" class="Symbol">(</a><a id="3619" href="type-former.equiv.html#3552" class="Bound">A</a> <a id="3621" href="fibration.fibration.html#8733" class="Function Operator">∘ᶠ</a> <a id="3624" href="type-former.equiv.html#3589" class="Bound">ρ</a><a id="3625" class="Symbol">)</a> <a id="3627" href="type-former.equiv.html#3389" class="Function Operator">≃ᶠ</a> <a id="3630" class="Symbol">(</a><a id="3631" href="type-former.equiv.html#3569" class="Bound">B</a> <a id="3633" href="fibration.fibration.html#8733" class="Function Operator">∘ᶠ</a> <a id="3636" href="type-former.equiv.html#3589" class="Bound">ρ</a><a id="3637" class="Symbol">)</a>
<a id="3639" href="type-former.equiv.html#3535" class="Function">reindexEquivᶠ</a> <a id="3653" href="type-former.equiv.html#3653" class="Bound">ρ</a> <a id="3655" class="Symbol">=</a> <a id="3657" href="basic.sigma.html#676" class="Function">Σext</a> <a id="3662" href="basic.prelude.html#302" class="InductiveConstructor">refl</a> <a id="3667" class="Symbol">(</a><a id="3668" href="type-former.equiv.html#3104" class="Function">reindexEquivFibStr</a> <a id="3687" class="Symbol">_)</a>

<a id="3691" class="Comment">------------------------------------------------------------------------------------------</a>
<a id="3782" class="Comment">-- Being an equivalence is an h-proposition.</a>
<a id="3827" class="Comment">------------------------------------------------------------------------------------------</a>

<a id="3919" class="Keyword">opaque</a>
  <a id="IsEquivIshPropᶠ"></a><a id="3928" href="type-former.equiv.html#3928" class="Function">IsEquivIshPropᶠ</a> <a id="3944" class="Symbol">:</a> <a id="3946" class="Symbol">(</a><a id="3947" href="type-former.equiv.html#3947" class="Bound">A</a> <a id="3949" class="Symbol">:</a> <a id="3951" href="type-former.equiv.html#446" class="Generalizable">Γ</a> <a id="3953" href="fibration.fibration.html#7526" class="Function Operator">⊢ᶠType</a> <a id="3960" href="type-former.equiv.html#427" class="Generalizable">ℓ</a><a id="3961" class="Symbol">)</a> <a id="3963" class="Symbol">(</a><a id="3964" href="type-former.equiv.html#3964" class="Bound">B</a> <a id="3966" class="Symbol">:</a> <a id="3968" href="type-former.equiv.html#446" class="Generalizable">Γ</a> <a id="3970" href="fibration.fibration.html#7526" class="Function Operator">⊢ᶠType</a> <a id="3977" href="type-former.equiv.html#429" class="Generalizable">ℓ&#39;</a><a id="3979" class="Symbol">)</a> <a id="3981" class="Symbol">(</a><a id="3982" href="type-former.equiv.html#3982" class="Bound">f</a> <a id="3984" class="Symbol">:</a> <a id="3986" href="type-former.equiv.html#446" class="Generalizable">Γ</a> <a id="3988" href="fibration.fibration.html#8007" class="Function Operator">⊢ᶠ</a> <a id="3991" href="type-former.equiv.html#3947" class="Bound">A</a> <a id="3993" href="type-former.pi.html#2817" class="Function Operator">→ᶠ</a> <a id="3996" href="type-former.equiv.html#3964" class="Bound">B</a><a id="3997" class="Symbol">)</a>
    <a id="4003" class="Symbol">→</a> <a id="4005" href="type-former.equiv.html#446" class="Generalizable">Γ</a> <a id="4007" href="fibration.fibration.html#8007" class="Function Operator">⊢ᶠ</a> <a id="4010" href="type-former.hlevels.html#2918" class="Function">IshPropᶠ</a> <a id="4019" class="Symbol">(</a><a id="4020" href="type-former.equiv.html#2723" class="Function">IsEquivᶠ</a> <a id="4029" href="type-former.equiv.html#3947" class="Bound">A</a> <a id="4031" href="type-former.equiv.html#3964" class="Bound">B</a> <a id="4033" href="type-former.equiv.html#3982" class="Bound">f</a><a id="4034" class="Symbol">)</a>
  <a id="4038" href="type-former.equiv.html#3928" class="Function">IsEquivIshPropᶠ</a> <a id="4054" href="type-former.equiv.html#4054" class="Bound">A</a> <a id="4056" href="type-former.equiv.html#4056" class="Bound">B</a> <a id="4058" href="type-former.equiv.html#4058" class="Bound">f</a> <a id="4060" class="Symbol">=</a>
    <a id="4066" href="type-former.hlevels.html#4623" class="Function">ΠIshPropᶠ</a>
      <a id="4082" href="type-former.equiv.html#4056" class="Bound">B</a>
      <a id="4090" class="Symbol">(</a><a id="4091" href="type-former.hlevels.html#1290" class="Function">IsContrᶠ</a> <a id="4100" class="Symbol">(</a><a id="4101" href="type-former.path.html#4403" class="Function">Fiberᶠ</a> <a id="4108" class="Symbol">(</a><a id="4109" href="type-former.equiv.html#4054" class="Bound">A</a> <a id="4111" href="fibration.fibration.html#8733" class="Function Operator">∘ᶠ</a> <a id="4114" href="internal-extensional-type-theory.html#2013" class="Function">𝒑</a><a id="4115" class="Symbol">)</a> <a id="4117" class="Symbol">(</a><a id="4118" href="type-former.equiv.html#4056" class="Bound">B</a> <a id="4120" href="fibration.fibration.html#8733" class="Function Operator">∘ᶠ</a> <a id="4123" href="internal-extensional-type-theory.html#2013" class="Function">𝒑</a><a id="4124" class="Symbol">)</a> <a id="4126" class="Symbol">(</a><a id="4127" href="type-former.equiv.html#4058" class="Bound">f</a> <a id="4129" href="basic.function.html#441" class="Function Operator">∘</a> <a id="4131" href="internal-extensional-type-theory.html#2013" class="Function">𝒑</a><a id="4132" class="Symbol">)</a> <a id="4134" href="internal-extensional-type-theory.html#2153" class="Function">𝒒</a><a id="4135" class="Symbol">))</a>
      <a id="4144" class="Symbol">(</a><a id="4145" href="type-former.hlevels.html#3065" class="Function">IsContrIshPropᶠ</a> <a id="4161" class="Symbol">(</a><a id="4162" href="type-former.path.html#4403" class="Function">Fiberᶠ</a> <a id="4169" class="Symbol">(</a><a id="4170" href="type-former.equiv.html#4054" class="Bound">A</a> <a id="4172" href="fibration.fibration.html#8733" class="Function Operator">∘ᶠ</a> <a id="4175" href="internal-extensional-type-theory.html#2013" class="Function">𝒑</a><a id="4176" class="Symbol">)</a> <a id="4178" class="Symbol">(</a><a id="4179" href="type-former.equiv.html#4056" class="Bound">B</a> <a id="4181" href="fibration.fibration.html#8733" class="Function Operator">∘ᶠ</a> <a id="4184" href="internal-extensional-type-theory.html#2013" class="Function">𝒑</a><a id="4185" class="Symbol">)</a> <a id="4187" class="Symbol">(</a><a id="4188" href="type-former.equiv.html#4058" class="Bound">f</a> <a id="4190" href="basic.function.html#441" class="Function Operator">∘</a> <a id="4192" href="internal-extensional-type-theory.html#2013" class="Function">𝒑</a><a id="4193" class="Symbol">)</a> <a id="4195" href="internal-extensional-type-theory.html#2153" class="Function">𝒒</a><a id="4196" class="Symbol">))</a>

<a id="4200" class="Comment">--↓ To construct a path between equivalences, it suffices to build a path between the</a>
<a id="4286" class="Comment">--↓ underlying functions.</a>

<a id="4313" class="Keyword">opaque</a>
  <a id="equivPathᶠ"></a><a id="4322" href="type-former.equiv.html#4322" class="Function">equivPathᶠ</a> <a id="4333" class="Symbol">:</a> <a id="4335" class="Symbol">(</a><a id="4336" href="type-former.equiv.html#4336" class="Bound">A</a> <a id="4338" class="Symbol">:</a> <a id="4340" href="type-former.equiv.html#446" class="Generalizable">Γ</a> <a id="4342" href="fibration.fibration.html#7526" class="Function Operator">⊢ᶠType</a> <a id="4349" href="type-former.equiv.html#427" class="Generalizable">ℓ</a><a id="4350" class="Symbol">)</a> <a id="4352" class="Symbol">(</a><a id="4353" href="type-former.equiv.html#4353" class="Bound">B</a> <a id="4355" class="Symbol">:</a> <a id="4357" href="type-former.equiv.html#446" class="Generalizable">Γ</a> <a id="4359" href="fibration.fibration.html#7526" class="Function Operator">⊢ᶠType</a> <a id="4366" href="type-former.equiv.html#429" class="Generalizable">ℓ&#39;</a><a id="4368" class="Symbol">)</a> <a id="4370" class="Symbol">(</a><a id="4371" href="type-former.equiv.html#4371" class="Bound">e₀</a> <a id="4374" href="type-former.equiv.html#4374" class="Bound">e₁</a> <a id="4377" class="Symbol">:</a> <a id="4379" href="type-former.equiv.html#446" class="Generalizable">Γ</a> <a id="4381" href="fibration.fibration.html#8007" class="Function Operator">⊢ᶠ</a> <a id="4384" href="type-former.equiv.html#4336" class="Bound">A</a> <a id="4386" href="type-former.equiv.html#3389" class="Function Operator">≃ᶠ</a> <a id="4389" href="type-former.equiv.html#4353" class="Bound">B</a><a id="4390" class="Symbol">)</a>
    <a id="4396" class="Symbol">→</a> <a id="4398" href="type-former.equiv.html#446" class="Generalizable">Γ</a> <a id="4400" href="fibration.fibration.html#8007" class="Function Operator">⊢ᶠ</a> <a id="4403" href="type-former.path.html#3018" class="Function">Pathᶠ</a> <a id="4409" class="Symbol">(</a><a id="4410" href="type-former.equiv.html#4336" class="Bound">A</a> <a id="4412" href="type-former.pi.html#2817" class="Function Operator">→ᶠ</a> <a id="4415" href="type-former.equiv.html#4353" class="Bound">B</a><a id="4416" class="Symbol">)</a> <a id="4418" class="Symbol">(</a><a id="4419" href="internal-extensional-type-theory.html#3341" class="Function">fstˣ</a> <a id="4424" href="type-former.equiv.html#4371" class="Bound">e₀</a><a id="4426" class="Symbol">)</a> <a id="4428" class="Symbol">(</a><a id="4429" href="internal-extensional-type-theory.html#3341" class="Function">fstˣ</a> <a id="4434" href="type-former.equiv.html#4374" class="Bound">e₁</a><a id="4436" class="Symbol">)</a>
    <a id="4442" class="Symbol">→</a> <a id="4444" href="type-former.equiv.html#446" class="Generalizable">Γ</a> <a id="4446" href="fibration.fibration.html#8007" class="Function Operator">⊢ᶠ</a> <a id="4449" href="type-former.path.html#3018" class="Function">Pathᶠ</a> <a id="4455" class="Symbol">(</a><a id="4456" href="type-former.equiv.html#4336" class="Bound">A</a> <a id="4458" href="type-former.equiv.html#3389" class="Function Operator">≃ᶠ</a> <a id="4461" href="type-former.equiv.html#4353" class="Bound">B</a><a id="4462" class="Symbol">)</a> <a id="4464" href="type-former.equiv.html#4371" class="Bound">e₀</a> <a id="4467" href="type-former.equiv.html#4374" class="Bound">e₁</a>
  <a id="4472" href="type-former.equiv.html#4322" class="Function">equivPathᶠ</a> <a id="4483" href="type-former.equiv.html#4483" class="Bound">A</a> <a id="4485" href="type-former.equiv.html#4485" class="Bound">B</a> <a id="4487" href="type-former.equiv.html#4487" class="Bound">e₀</a> <a id="4490" href="type-former.equiv.html#4490" class="Bound">e₁</a> <a id="4493" href="type-former.equiv.html#4493" class="Bound">p</a> <a id="4495" class="Symbol">=</a>
    <a id="4501" href="internal-extensional-type-theory.html#2692" class="Function">appˣ</a>
      <a id="4512" class="Symbol">(</a><a id="4513" href="type-former.path.html#8166" class="Function">Jᶠ</a> <a id="4516" class="Symbol">(</a><a id="4517" href="type-former.equiv.html#4483" class="Bound">A</a> <a id="4519" href="type-former.pi.html#2817" class="Function Operator">→ᶠ</a> <a id="4522" href="type-former.equiv.html#4485" class="Bound">B</a><a id="4523" class="Symbol">)</a> <a id="4525" class="Symbol">(</a><a id="4526" href="internal-extensional-type-theory.html#3341" class="Function">fstˣ</a> <a id="4531" href="type-former.equiv.html#4490" class="Bound">e₁</a><a id="4533" class="Symbol">)</a>
        <a id="4543" class="Symbol">(</a><a id="4544" href="type-former.pi.html#2646" class="Function">Πᶠ</a> <a id="4547" class="Symbol">(</a><a id="4548" href="type-former.equiv.html#2723" class="Function">IsEquivᶠ</a> <a id="4557" class="Symbol">(</a><a id="4558" href="type-former.equiv.html#4483" class="Bound">A</a> <a id="4560" href="fibration.fibration.html#8733" class="Function Operator">∘ᶠ</a> <a id="4563" href="internal-extensional-type-theory.html#2013" class="Function">𝒑</a><a id="4564" class="Symbol">)</a> <a id="4566" class="Symbol">(</a><a id="4567" href="type-former.equiv.html#4485" class="Bound">B</a> <a id="4569" href="fibration.fibration.html#8733" class="Function Operator">∘ᶠ</a> <a id="4572" href="internal-extensional-type-theory.html#2013" class="Function">𝒑</a><a id="4573" class="Symbol">)</a> <a id="4575" class="Symbol">(</a><a id="4576" href="internal-extensional-type-theory.html#3341" class="Function">fstˣ</a> <a id="4581" href="internal-extensional-type-theory.html#2153" class="Function">𝒒</a><a id="4582" class="Symbol">))</a>
          <a id="4595" class="Symbol">(</a><a id="4596" href="type-former.path.html#3018" class="Function">Pathᶠ</a> <a id="4602" class="Symbol">(</a><a id="4603" href="type-former.equiv.html#4483" class="Bound">A</a> <a id="4605" href="type-former.equiv.html#3389" class="Function Operator">≃ᶠ</a> <a id="4608" href="type-former.equiv.html#4485" class="Bound">B</a> <a id="4610" href="fibration.fibration.html#8733" class="Function Operator">∘ᶠ</a> <a id="4613" href="internal-extensional-type-theory.html#2013" class="Function">𝒑</a> <a id="4615" href="fibration.fibration.html#8733" class="Function Operator">∘ᶠ</a> <a id="4618" href="internal-extensional-type-theory.html#2013" class="Function">𝒑</a><a id="4619" class="Symbol">)</a>
            <a id="4633" class="Symbol">(</a><a id="4634" href="internal-extensional-type-theory.html#3341" class="Function">fstˣ</a> <a id="4639" class="Symbol">(</a><a id="4640" href="internal-extensional-type-theory.html#2153" class="Function">𝒒</a> <a id="4642" href="basic.function.html#441" class="Function Operator">∘</a> <a id="4644" href="internal-extensional-type-theory.html#2013" class="Function">𝒑</a><a id="4645" class="Symbol">)</a> <a id="4647" href="internal-extensional-type-theory.html#3199" class="Function Operator">,ˣ</a> <a id="4650" href="internal-extensional-type-theory.html#2153" class="Function">𝒒</a><a id="4651" class="Symbol">)</a>
            <a id="4665" class="Symbol">(</a><a id="4666" href="type-former.equiv.html#4490" class="Bound">e₁</a> <a id="4669" href="basic.function.html#441" class="Function Operator">∘</a> <a id="4671" href="internal-extensional-type-theory.html#2013" class="Function">𝒑</a> <a id="4673" href="basic.function.html#441" class="Function Operator">∘</a> <a id="4675" href="internal-extensional-type-theory.html#2013" class="Function">𝒑</a><a id="4676" class="Symbol">)))</a>
        <a id="4688" class="Symbol">(</a><a id="4689" href="internal-extensional-type-theory.html#2593" class="Function">λˣ</a> <a id="4692" href="basic.function.html#647" class="Function Operator">$</a>
          <a id="4704" href="type-former.path.html#1365" class="Function">congPathˣ</a>
            <a id="4726" class="Symbol">(</a><a id="4727" href="internal-extensional-type-theory.html#2593" class="Function">λˣ</a> <a id="4730" class="Symbol">(</a><a id="4731" href="internal-extensional-type-theory.html#3341" class="Function">fstˣ</a> <a id="4736" href="type-former.equiv.html#4490" class="Bound">e₁</a> <a id="4739" href="basic.function.html#441" class="Function Operator">∘</a> <a id="4741" href="internal-extensional-type-theory.html#2013" class="Function">𝒑</a> <a id="4743" href="basic.function.html#441" class="Function Operator">∘</a> <a id="4745" href="internal-extensional-type-theory.html#2013" class="Function">𝒑</a> <a id="4747" href="internal-extensional-type-theory.html#3199" class="Function Operator">,ˣ</a> <a id="4750" href="internal-extensional-type-theory.html#2153" class="Function">𝒒</a><a id="4751" class="Symbol">))</a>
            <a id="4766" class="Symbol">(</a><a id="4767" href="internal-extensional-type-theory.html#2692" class="Function">appˣ</a> <a id="4772" class="Symbol">(</a><a id="4773" href="internal-extensional-type-theory.html#2692" class="Function">appˣ</a> <a id="4778" class="Symbol">(</a><a id="4779" href="type-former.equiv.html#3928" class="Function">IsEquivIshPropᶠ</a> <a id="4795" href="type-former.equiv.html#4483" class="Bound">A</a> <a id="4797" href="type-former.equiv.html#4485" class="Bound">B</a> <a id="4799" class="Symbol">(</a><a id="4800" href="internal-extensional-type-theory.html#3341" class="Function">fstˣ</a> <a id="4805" href="type-former.equiv.html#4490" class="Bound">e₁</a><a id="4807" class="Symbol">)</a> <a id="4809" href="basic.function.html#441" class="Function Operator">∘</a> <a id="4811" href="internal-extensional-type-theory.html#2013" class="Function">𝒑</a><a id="4812" class="Symbol">)</a> <a id="4814" href="internal-extensional-type-theory.html#2153" class="Function">𝒒</a><a id="4815" class="Symbol">)</a> <a id="4817" class="Symbol">(</a><a id="4818" href="internal-extensional-type-theory.html#3428" class="Function">sndˣ</a> <a id="4823" href="type-former.equiv.html#4490" class="Bound">e₁</a> <a id="4826" href="basic.function.html#441" class="Function Operator">∘</a> <a id="4828" href="internal-extensional-type-theory.html#2013" class="Function">𝒑</a><a id="4829" class="Symbol">)))</a>
        <a id="4841" class="Symbol">(</a><a id="4842" href="internal-extensional-type-theory.html#3341" class="Function">fstˣ</a> <a id="4847" href="type-former.equiv.html#4487" class="Bound">e₀</a> <a id="4850" href="internal-extensional-type-theory.html#3199" class="Function Operator">,ˣ</a> <a id="4853" href="type-former.equiv.html#4493" class="Bound">p</a><a id="4854" class="Symbol">))</a>
      <a id="4863" class="Symbol">(</a><a id="4864" href="internal-extensional-type-theory.html#3428" class="Function">sndˣ</a> <a id="4869" href="type-former.equiv.html#4487" class="Bound">e₀</a><a id="4871" class="Symbol">)</a>

<a id="4874" class="Comment">------------------------------------------------------------------------------------------</a>
<a id="4965" class="Comment">-- A map f : A → B between fibrant types is an equivalence if and only if its fiber family</a>
<a id="5056" class="Comment">-- is a trivial fibration.</a>
<a id="5083" class="Comment">------------------------------------------------------------------------------------------</a>

<a id="equivToFiberTFib"></a><a id="5175" href="type-former.equiv.html#5175" class="Function">equivToFiberTFib</a> <a id="5192" class="Symbol">:</a> <a id="5194" class="Symbol">(</a><a id="5195" href="type-former.equiv.html#5195" class="Bound">A</a> <a id="5197" class="Symbol">:</a> <a id="5199" href="type-former.equiv.html#446" class="Generalizable">Γ</a> <a id="5201" href="fibration.fibration.html#7526" class="Function Operator">⊢ᶠType</a> <a id="5208" href="type-former.equiv.html#427" class="Generalizable">ℓ</a><a id="5209" class="Symbol">)</a> <a id="5211" class="Symbol">(</a><a id="5212" href="type-former.equiv.html#5212" class="Bound">B</a> <a id="5214" class="Symbol">:</a> <a id="5216" href="type-former.equiv.html#446" class="Generalizable">Γ</a> <a id="5218" href="fibration.fibration.html#7526" class="Function Operator">⊢ᶠType</a> <a id="5225" href="type-former.equiv.html#429" class="Generalizable">ℓ&#39;</a><a id="5227" class="Symbol">)</a>
  <a id="5231" class="Symbol">(</a><a id="5232" href="type-former.equiv.html#5232" class="Bound">e</a> <a id="5234" class="Symbol">:</a> <a id="5236" href="type-former.equiv.html#446" class="Generalizable">Γ</a> <a id="5238" href="fibration.fibration.html#8007" class="Function Operator">⊢ᶠ</a> <a id="5241" href="type-former.equiv.html#5195" class="Bound">A</a> <a id="5243" href="type-former.equiv.html#3389" class="Function Operator">≃ᶠ</a> <a id="5246" href="type-former.equiv.html#5212" class="Bound">B</a><a id="5247" class="Symbol">)</a> <a id="5249" class="Symbol">→</a> <a id="5251" href="fibration.trivial.html#565" class="Function">TFibStr</a> <a id="5259" class="Symbol">(</a><a id="5260" href="type-former.path.html#3730" class="Function">Fiberˣ</a> <a id="5267" class="Symbol">(</a><a id="5268" href="internal-extensional-type-theory.html#3341" class="Function">fstˣ</a> <a id="5273" href="type-former.equiv.html#5232" class="Bound">e</a> <a id="5275" href="basic.function.html#441" class="Function Operator">∘</a> <a id="5277" href="internal-extensional-type-theory.html#2013" class="Function">𝒑</a><a id="5278" class="Symbol">)</a> <a id="5280" href="internal-extensional-type-theory.html#2153" class="Function">𝒒</a><a id="5281" class="Symbol">)</a>
<a id="5283" href="type-former.equiv.html#5175" class="Function">equivToFiberTFib</a> <a id="5300" href="type-former.equiv.html#5300" class="Bound">A</a> <a id="5302" href="type-former.equiv.html#5302" class="Bound">B</a> <a id="5304" href="type-former.equiv.html#5304" class="Bound">e</a> <a id="5306" class="Symbol">=</a>
  <a id="5310" href="type-former.hlevels.html#1403" class="Function">isContrToTFibStr</a>
    <a id="5331" class="Symbol">(</a><a id="5332" href="type-former.path.html#4403" class="Function">Fiberᶠ</a> <a id="5339" class="Symbol">(</a><a id="5340" href="type-former.equiv.html#5300" class="Bound">A</a> <a id="5342" href="fibration.fibration.html#8733" class="Function Operator">∘ᶠ</a> <a id="5345" href="internal-extensional-type-theory.html#2013" class="Function">𝒑</a><a id="5346" class="Symbol">)</a> <a id="5348" class="Symbol">(</a><a id="5349" href="type-former.equiv.html#5302" class="Bound">B</a> <a id="5351" href="fibration.fibration.html#8733" class="Function Operator">∘ᶠ</a> <a id="5354" href="internal-extensional-type-theory.html#2013" class="Function">𝒑</a><a id="5355" class="Symbol">)</a> <a id="5357" class="Symbol">(</a><a id="5358" href="internal-extensional-type-theory.html#3341" class="Function">fstˣ</a> <a id="5363" href="type-former.equiv.html#5304" class="Bound">e</a> <a id="5365" href="basic.function.html#441" class="Function Operator">∘</a> <a id="5367" href="internal-extensional-type-theory.html#2013" class="Function">𝒑</a><a id="5368" class="Symbol">)</a> <a id="5370" href="internal-extensional-type-theory.html#2153" class="Function">𝒒</a><a id="5371" class="Symbol">)</a>
    <a id="5377" class="Symbol">(</a><a id="5378" href="internal-extensional-type-theory.html#2692" class="Function">appˣ</a> <a id="5383" class="Symbol">(</a><a id="5384" href="internal-extensional-type-theory.html#3428" class="Function">sndˣ</a> <a id="5389" class="Symbol">(</a><a id="5390" href="type-former.equiv.html#5304" class="Bound">e</a> <a id="5392" href="basic.function.html#441" class="Function Operator">∘</a> <a id="5394" href="internal-extensional-type-theory.html#2013" class="Function">𝒑</a><a id="5395" class="Symbol">))</a> <a id="5398" href="internal-extensional-type-theory.html#2153" class="Function">𝒒</a><a id="5399" class="Symbol">)</a>

<a id="fiberTFibToIsEquiv"></a><a id="5402" href="type-former.equiv.html#5402" class="Function">fiberTFibToIsEquiv</a> <a id="5421" class="Symbol">:</a> <a id="5423" class="Symbol">(</a><a id="5424" href="type-former.equiv.html#5424" class="Bound">A</a> <a id="5426" class="Symbol">:</a> <a id="5428" href="type-former.equiv.html#446" class="Generalizable">Γ</a> <a id="5430" href="fibration.fibration.html#7526" class="Function Operator">⊢ᶠType</a> <a id="5437" href="type-former.equiv.html#427" class="Generalizable">ℓ</a><a id="5438" class="Symbol">)</a> <a id="5440" class="Symbol">(</a><a id="5441" href="type-former.equiv.html#5441" class="Bound">B</a> <a id="5443" class="Symbol">:</a> <a id="5445" href="type-former.equiv.html#446" class="Generalizable">Γ</a> <a id="5447" href="fibration.fibration.html#7526" class="Function Operator">⊢ᶠType</a> <a id="5454" href="type-former.equiv.html#429" class="Generalizable">ℓ&#39;</a><a id="5456" class="Symbol">)</a> <a id="5458" class="Symbol">{</a><a id="5459" href="type-former.equiv.html#5459" class="Bound">f</a> <a id="5461" class="Symbol">:</a> <a id="5463" href="type-former.equiv.html#446" class="Generalizable">Γ</a> <a id="5465" href="fibration.fibration.html#8007" class="Function Operator">⊢ᶠ</a> <a id="5468" href="type-former.equiv.html#5424" class="Bound">A</a> <a id="5470" href="type-former.pi.html#2817" class="Function Operator">→ᶠ</a> <a id="5473" href="type-former.equiv.html#5441" class="Bound">B</a><a id="5474" class="Symbol">}</a>
  <a id="5478" class="Symbol">→</a> <a id="5480" href="fibration.trivial.html#565" class="Function">TFibStr</a> <a id="5488" class="Symbol">(</a><a id="5489" href="type-former.path.html#3730" class="Function">Fiberˣ</a> <a id="5496" class="Symbol">(</a><a id="5497" href="type-former.equiv.html#5459" class="Bound">f</a> <a id="5499" href="basic.function.html#441" class="Function Operator">∘</a> <a id="5501" href="internal-extensional-type-theory.html#2013" class="Function">𝒑</a><a id="5502" class="Symbol">)</a> <a id="5504" href="internal-extensional-type-theory.html#2153" class="Function">𝒒</a><a id="5505" class="Symbol">)</a> <a id="5507" class="Symbol">→</a> <a id="5509" href="type-former.equiv.html#446" class="Generalizable">Γ</a> <a id="5511" href="fibration.fibration.html#8007" class="Function Operator">⊢ᶠ</a> <a id="5514" href="type-former.equiv.html#2723" class="Function">IsEquivᶠ</a> <a id="5523" href="type-former.equiv.html#5424" class="Bound">A</a> <a id="5525" href="type-former.equiv.html#5441" class="Bound">B</a> <a id="5527" href="type-former.equiv.html#5459" class="Bound">f</a>
<a id="5529" href="type-former.equiv.html#5402" class="Function">fiberTFibToIsEquiv</a> <a id="5548" href="type-former.equiv.html#5548" class="Bound">A</a> <a id="5550" href="type-former.equiv.html#5550" class="Bound">B</a> <a id="5552" href="type-former.equiv.html#5552" class="Bound">c</a> <a id="5554" class="Symbol">=</a> <a id="5556" href="basic.sigma.html#1337" class="Function">curry</a> <a id="5562" class="Symbol">(</a><a id="5563" href="type-former.hlevels.html#1777" class="Function">TFibToIsContr</a> <a id="5577" class="Symbol">(_</a> <a id="5580" href="basic.sigma.html#265" class="InductiveConstructor Operator">,</a> <a id="5582" href="type-former.equiv.html#5552" class="Bound">c</a><a id="5583" class="Symbol">))</a>

<a id="5587" class="Comment">------------------------------------------------------------------------------------------</a>
<a id="5678" class="Comment">-- Identity and transport functions are equivalences.</a>
<a id="5732" class="Comment">------------------------------------------------------------------------------------------</a>

<a id="5824" class="Keyword">opaque</a>
  <a id="idEquivᶠ"></a><a id="5833" href="type-former.equiv.html#5833" class="Function">idEquivᶠ</a> <a id="5842" class="Symbol">:</a> <a id="5844" class="Symbol">(</a><a id="5845" href="type-former.equiv.html#5845" class="Bound">A</a> <a id="5847" class="Symbol">:</a> <a id="5849" href="type-former.equiv.html#446" class="Generalizable">Γ</a> <a id="5851" href="fibration.fibration.html#7526" class="Function Operator">⊢ᶠType</a> <a id="5858" href="type-former.equiv.html#427" class="Generalizable">ℓ</a><a id="5859" class="Symbol">)</a> <a id="5861" class="Symbol">→</a> <a id="5863" href="type-former.equiv.html#446" class="Generalizable">Γ</a> <a id="5865" href="fibration.fibration.html#8007" class="Function Operator">⊢ᶠ</a> <a id="5868" href="type-former.equiv.html#5845" class="Bound">A</a> <a id="5870" href="type-former.equiv.html#3389" class="Function Operator">≃ᶠ</a> <a id="5873" href="type-former.equiv.html#5845" class="Bound">A</a>
  <a id="5877" href="type-former.equiv.html#5833" class="Function">idEquivᶠ</a> <a id="5886" href="type-former.equiv.html#5886" class="Bound">A</a> <a id="5888" class="Symbol">=</a> <a id="5890" href="internal-extensional-type-theory.html#2593" class="Function">λˣ</a> <a id="5893" href="internal-extensional-type-theory.html#2153" class="Function">𝒒</a> <a id="5895" href="internal-extensional-type-theory.html#3199" class="Function Operator">,ˣ</a> <a id="5898" href="internal-extensional-type-theory.html#2593" class="Function">λˣ</a> <a id="5901" class="Symbol">(</a><a id="5902" href="type-former.hlevels.html#2429" class="Function">singlIsContrᶠ</a> <a id="5916" class="Symbol">(</a><a id="5917" href="type-former.equiv.html#5886" class="Bound">A</a> <a id="5919" href="fibration.fibration.html#8733" class="Function Operator">∘ᶠ</a> <a id="5922" href="internal-extensional-type-theory.html#2013" class="Function">𝒑</a><a id="5923" class="Symbol">)</a> <a id="5925" href="internal-extensional-type-theory.html#2153" class="Function">𝒒</a><a id="5926" class="Symbol">)</a>

  <a id="reindexIdEquivᶠ"></a><a id="5931" href="type-former.equiv.html#5931" class="Function">reindexIdEquivᶠ</a> <a id="5947" class="Symbol">:</a> <a id="5949" class="Symbol">{</a><a id="5950" href="type-former.equiv.html#5950" class="Bound">A</a> <a id="5952" class="Symbol">:</a> <a id="5954" href="type-former.equiv.html#446" class="Generalizable">Γ</a> <a id="5956" href="fibration.fibration.html#7526" class="Function Operator">⊢ᶠType</a> <a id="5963" href="type-former.equiv.html#427" class="Generalizable">ℓ</a><a id="5964" class="Symbol">}</a> <a id="5966" class="Symbol">(</a><a id="5967" href="type-former.equiv.html#5967" class="Bound">ρ</a> <a id="5969" class="Symbol">:</a> <a id="5971" href="type-former.equiv.html#448" class="Generalizable">Δ</a> <a id="5973" class="Symbol">→</a> <a id="5975" href="type-former.equiv.html#446" class="Generalizable">Γ</a><a id="5976" class="Symbol">)</a>
    <a id="5982" class="Symbol">→</a> <a id="5984" href="type-former.equiv.html#5833" class="Function">idEquivᶠ</a> <a id="5993" href="type-former.equiv.html#5950" class="Bound">A</a> <a id="5995" href="basic.function.html#441" class="Function Operator">∘</a> <a id="5997" href="type-former.equiv.html#5967" class="Bound">ρ</a> <a id="5999" href="basic.prelude.html#239" class="Datatype Operator">≡</a> <a id="6001" href="type-former.equiv.html#5833" class="Function">idEquivᶠ</a> <a id="6010" class="Symbol">(</a><a id="6011" href="type-former.equiv.html#5950" class="Bound">A</a> <a id="6013" href="fibration.fibration.html#8733" class="Function Operator">∘ᶠ</a> <a id="6016" href="type-former.equiv.html#5967" class="Bound">ρ</a><a id="6017" class="Symbol">)</a>
  <a id="6021" href="type-former.equiv.html#5931" class="Function">reindexIdEquivᶠ</a> <a id="6037" href="type-former.equiv.html#6037" class="Bound">ρ</a> <a id="6039" class="Symbol">=</a> <a id="6041" href="basic.prelude.html#302" class="InductiveConstructor">refl</a>

<a id="6047" class="Keyword">opaque</a>
  <a id="transpEquiv"></a><a id="6056" href="type-former.equiv.html#6056" class="Function">transpEquiv</a> <a id="6068" class="Symbol">:</a> <a id="6070" class="Symbol">(</a><a id="6071" href="type-former.equiv.html#6071" class="Bound">S</a> <a id="6073" class="Symbol">:</a> <a id="6075" href="axiom.shape.html#611" class="Postulate">Shape</a><a id="6080" class="Symbol">)</a>
    <a id="6086" class="Symbol">(</a><a id="6087" href="type-former.equiv.html#6087" class="Bound">A</a> <a id="6089" class="Symbol">:</a> <a id="6091" href="axiom.shape.html#626" class="Postulate Operator">⟨</a> <a id="6093" href="type-former.equiv.html#6071" class="Bound">S</a> <a id="6095" href="axiom.shape.html#626" class="Postulate Operator">⟩</a> <a id="6097" href="fibration.fibration.html#7526" class="Function Operator">⊢ᶠType</a> <a id="6104" href="type-former.equiv.html#427" class="Generalizable">ℓ</a><a id="6105" class="Symbol">)</a>
    <a id="6111" class="Symbol">(</a><a id="6112" href="type-former.equiv.html#6112" class="Bound">r</a> <a id="6114" href="type-former.equiv.html#6114" class="Bound">s</a> <a id="6116" class="Symbol">:</a> <a id="6118" href="axiom.shape.html#626" class="Postulate Operator">⟨</a> <a id="6120" href="type-former.equiv.html#6071" class="Bound">S</a> <a id="6122" href="axiom.shape.html#626" class="Postulate Operator">⟩</a><a id="6123" class="Symbol">)</a> <a id="6125" class="Symbol">→</a> <a id="6127" class="Symbol">(</a><a id="6128" href="type-former.equiv.html#6087" class="Bound">A</a> <a id="6130" href="fibration.fibration.html#7867" class="Function Operator">$ᶠ</a> <a id="6133" href="type-former.equiv.html#6112" class="Bound">r</a><a id="6134" class="Symbol">)</a> <a id="6136" href="type-former.equiv.html#775" class="Function Operator">≃</a> <a id="6138" class="Symbol">(</a><a id="6139" href="type-former.equiv.html#6087" class="Bound">A</a> <a id="6141" href="fibration.fibration.html#7867" class="Function Operator">$ᶠ</a> <a id="6144" href="type-former.equiv.html#6114" class="Bound">s</a><a id="6145" class="Symbol">)</a>
  <a id="6149" href="type-former.equiv.html#6056" class="Function">transpEquiv</a> <a id="6161" href="type-former.equiv.html#6161" class="Bound">S</a> <a id="6163" href="type-former.equiv.html#6163" class="Bound">A</a> <a id="6165" href="type-former.equiv.html#6165" class="Bound">r</a> <a id="6167" href="type-former.equiv.html#6167" class="Bound">s</a> <a id="6169" class="Symbol">=</a>
    <a id="6175" href="fibration.transport.html#1963" class="Function">fibTranspStr</a> <a id="6188" class="Symbol">((</a><a id="6190" href="type-former.equiv.html#6163" class="Bound">A</a> <a id="6192" href="fibration.fibration.html#8733" class="Function Operator">∘ᶠ</a> <a id="6195" href="basic.function.html#339" class="Function">cst</a> <a id="6199" href="type-former.equiv.html#6165" class="Bound">r</a><a id="6200" class="Symbol">)</a> <a id="6202" href="type-former.equiv.html#3389" class="Function Operator">≃ᶠ</a> <a id="6205" href="type-former.equiv.html#6163" class="Bound">A</a><a id="6206" class="Symbol">)</a> <a id="6208" class="Symbol">.</a><a id="6209" href="fibration.transport.html#509" class="Field">lift</a> <a id="6214" href="type-former.equiv.html#6161" class="Bound">S</a> <a id="6216" href="basic.function.html#279" class="Function">id</a> <a id="6219" href="type-former.equiv.html#6165" class="Bound">r</a> <a id="6221" class="Symbol">(</a><a id="6222" href="type-former.equiv.html#5833" class="Function">idEquivᶠ</a> <a id="6231" href="type-former.equiv.html#6163" class="Bound">A</a> <a id="6233" href="type-former.equiv.html#6165" class="Bound">r</a><a id="6234" class="Symbol">)</a> <a id="6236" href="type-former.equiv.html#6167" class="Bound">s</a>

  <a id="transpEquivCap"></a><a id="6241" href="type-former.equiv.html#6241" class="Function">transpEquivCap</a> <a id="6256" class="Symbol">:</a> <a id="6258" class="Symbol">(</a><a id="6259" href="type-former.equiv.html#6259" class="Bound">S</a> <a id="6261" class="Symbol">:</a> <a id="6263" href="axiom.shape.html#611" class="Postulate">Shape</a><a id="6268" class="Symbol">)</a>
    <a id="6274" class="Symbol">(</a><a id="6275" href="type-former.equiv.html#6275" class="Bound">A</a> <a id="6277" class="Symbol">:</a> <a id="6279" href="axiom.shape.html#626" class="Postulate Operator">⟨</a> <a id="6281" href="type-former.equiv.html#6259" class="Bound">S</a> <a id="6283" href="axiom.shape.html#626" class="Postulate Operator">⟩</a> <a id="6285" href="fibration.fibration.html#7526" class="Function Operator">⊢ᶠType</a> <a id="6292" href="type-former.equiv.html#427" class="Generalizable">ℓ</a><a id="6293" class="Symbol">)</a>
    <a id="6299" class="Symbol">(</a><a id="6300" href="type-former.equiv.html#6300" class="Bound">r</a> <a id="6302" class="Symbol">:</a> <a id="6304" href="axiom.shape.html#626" class="Postulate Operator">⟨</a> <a id="6306" href="type-former.equiv.html#6259" class="Bound">S</a> <a id="6308" href="axiom.shape.html#626" class="Postulate Operator">⟩</a><a id="6309" class="Symbol">)</a> <a id="6311" class="Symbol">→</a> <a id="6313" href="type-former.equiv.html#6056" class="Function">transpEquiv</a> <a id="6325" href="type-former.equiv.html#6259" class="Bound">S</a> <a id="6327" href="type-former.equiv.html#6275" class="Bound">A</a> <a id="6329" href="type-former.equiv.html#6300" class="Bound">r</a> <a id="6331" href="type-former.equiv.html#6300" class="Bound">r</a> <a id="6333" href="basic.prelude.html#239" class="Datatype Operator">≡</a> <a id="6335" href="type-former.equiv.html#5833" class="Function">idEquivᶠ</a> <a id="6344" href="type-former.equiv.html#6275" class="Bound">A</a> <a id="6346" href="type-former.equiv.html#6300" class="Bound">r</a>
  <a id="6350" href="type-former.equiv.html#6241" class="Function">transpEquivCap</a> <a id="6365" href="type-former.equiv.html#6365" class="Bound">S</a> <a id="6367" href="type-former.equiv.html#6367" class="Bound">A</a> <a id="6369" href="type-former.equiv.html#6369" class="Bound">r</a> <a id="6371" class="Symbol">=</a>
    <a id="6377" href="fibration.transport.html#1963" class="Function">fibTranspStr</a> <a id="6390" class="Symbol">((</a><a id="6392" href="type-former.equiv.html#6367" class="Bound">A</a> <a id="6394" href="fibration.fibration.html#8733" class="Function Operator">∘ᶠ</a> <a id="6397" href="basic.function.html#339" class="Function">cst</a> <a id="6401" href="type-former.equiv.html#6369" class="Bound">r</a><a id="6402" class="Symbol">)</a> <a id="6404" href="type-former.equiv.html#3389" class="Function Operator">≃ᶠ</a> <a id="6407" href="type-former.equiv.html#6367" class="Bound">A</a><a id="6408" class="Symbol">)</a> <a id="6410" class="Symbol">.</a><a id="6411" href="fibration.transport.html#593" class="Field">cap≡</a> <a id="6416" href="type-former.equiv.html#6365" class="Bound">S</a> <a id="6418" href="basic.function.html#279" class="Function">id</a> <a id="6421" href="type-former.equiv.html#6369" class="Bound">r</a> <a id="6423" class="Symbol">(</a><a id="6424" href="type-former.equiv.html#5833" class="Function">idEquivᶠ</a> <a id="6433" href="type-former.equiv.html#6367" class="Bound">A</a> <a id="6435" href="type-former.equiv.html#6369" class="Bound">r</a><a id="6436" class="Symbol">)</a>

  <a id="transpEquivVary"></a><a id="6441" href="type-former.equiv.html#6441" class="Function">transpEquivVary</a> <a id="6457" class="Symbol">:</a> <a id="6459" class="Symbol">∀</a> <a id="6461" class="Symbol">{</a><a id="6462" href="type-former.equiv.html#6462" class="Bound">ℓ</a><a id="6463" class="Symbol">}</a> <a id="6465" class="Symbol">{</a><a id="6466" href="type-former.equiv.html#6466" class="Bound">S</a> <a id="6468" href="type-former.equiv.html#6468" class="Bound">T</a> <a id="6470" class="Symbol">:</a> <a id="6472" href="axiom.shape.html#611" class="Postulate">Shape</a><a id="6477" class="Symbol">}</a> <a id="6479" class="Symbol">(</a><a id="6480" href="type-former.equiv.html#6480" class="Bound">σ</a> <a id="6482" class="Symbol">:</a> <a id="6484" href="axiom.shape.html#1245" class="Postulate Operator">Shape[</a> <a id="6491" href="type-former.equiv.html#6466" class="Bound">S</a> <a id="6493" href="axiom.shape.html#1245" class="Postulate Operator">,</a> <a id="6495" href="type-former.equiv.html#6468" class="Bound">T</a> <a id="6497" href="axiom.shape.html#1245" class="Postulate Operator">]</a><a id="6498" class="Symbol">)</a>
    <a id="6504" class="Symbol">(</a><a id="6505" href="type-former.equiv.html#6505" class="Bound">A</a> <a id="6507" class="Symbol">:</a> <a id="6509" href="axiom.shape.html#626" class="Postulate Operator">⟨</a> <a id="6511" href="type-former.equiv.html#6468" class="Bound">T</a> <a id="6513" href="axiom.shape.html#626" class="Postulate Operator">⟩</a> <a id="6515" href="fibration.fibration.html#7526" class="Function Operator">⊢ᶠType</a> <a id="6522" href="type-former.equiv.html#6462" class="Bound">ℓ</a><a id="6523" class="Symbol">)</a>
    <a id="6529" class="Symbol">(</a><a id="6530" href="type-former.equiv.html#6530" class="Bound">r</a> <a id="6532" href="type-former.equiv.html#6532" class="Bound">s</a> <a id="6534" class="Symbol">:</a> <a id="6536" href="axiom.shape.html#626" class="Postulate Operator">⟨</a> <a id="6538" href="type-former.equiv.html#6466" class="Bound">S</a> <a id="6540" href="axiom.shape.html#626" class="Postulate Operator">⟩</a><a id="6541" class="Symbol">)</a>
    <a id="6547" class="Symbol">→</a> <a id="6549" href="type-former.equiv.html#6056" class="Function">transpEquiv</a> <a id="6561" href="type-former.equiv.html#6468" class="Bound">T</a> <a id="6563" href="type-former.equiv.html#6505" class="Bound">A</a> <a id="6565" class="Symbol">(</a><a id="6566" href="axiom.shape.html#1281" class="Postulate Operator">⟪</a> <a id="6568" href="type-former.equiv.html#6480" class="Bound">σ</a> <a id="6570" href="axiom.shape.html#1281" class="Postulate Operator">⟫</a> <a id="6572" href="type-former.equiv.html#6530" class="Bound">r</a><a id="6573" class="Symbol">)</a> <a id="6575" class="Symbol">(</a><a id="6576" href="axiom.shape.html#1281" class="Postulate Operator">⟪</a> <a id="6578" href="type-former.equiv.html#6480" class="Bound">σ</a> <a id="6580" href="axiom.shape.html#1281" class="Postulate Operator">⟫</a> <a id="6582" href="type-former.equiv.html#6532" class="Bound">s</a><a id="6583" class="Symbol">)</a> <a id="6585" href="basic.prelude.html#239" class="Datatype Operator">≡</a> <a id="6587" href="type-former.equiv.html#6056" class="Function">transpEquiv</a> <a id="6599" href="type-former.equiv.html#6466" class="Bound">S</a> <a id="6601" class="Symbol">(</a><a id="6602" href="type-former.equiv.html#6505" class="Bound">A</a> <a id="6604" href="fibration.fibration.html#8733" class="Function Operator">∘ᶠ</a> <a id="6607" href="axiom.shape.html#1281" class="Postulate Operator">⟪</a> <a id="6609" href="type-former.equiv.html#6480" class="Bound">σ</a> <a id="6611" href="axiom.shape.html#1281" class="Postulate Operator">⟫</a><a id="6612" class="Symbol">)</a> <a id="6614" href="type-former.equiv.html#6530" class="Bound">r</a> <a id="6616" href="type-former.equiv.html#6532" class="Bound">s</a>
  <a id="6620" href="type-former.equiv.html#6441" class="Function">transpEquivVary</a> <a id="6636" class="Symbol">{</a><a id="6637" class="Argument">S</a> <a id="6639" class="Symbol">=</a> <a id="6641" href="type-former.equiv.html#6641" class="Bound">S</a><a id="6642" class="Symbol">}</a> <a id="6644" href="type-former.equiv.html#6644" class="Bound">σ</a> <a id="6646" href="type-former.equiv.html#6646" class="Bound">A</a> <a id="6648" href="type-former.equiv.html#6648" class="Bound">r</a> <a id="6650" href="type-former.equiv.html#6650" class="Bound">s</a> <a id="6652" class="Symbol">=</a>
    <a id="6658" href="fibration.transport.html#1963" class="Function">fibTranspStr</a> <a id="6671" class="Symbol">((</a><a id="6673" href="type-former.equiv.html#6646" class="Bound">A</a> <a id="6675" href="fibration.fibration.html#8733" class="Function Operator">∘ᶠ</a> <a id="6678" href="basic.function.html#339" class="Function">cst</a> <a id="6682" class="Symbol">(</a><a id="6683" href="axiom.shape.html#1281" class="Postulate Operator">⟪</a> <a id="6685" href="type-former.equiv.html#6644" class="Bound">σ</a> <a id="6687" href="axiom.shape.html#1281" class="Postulate Operator">⟫</a> <a id="6689" href="type-former.equiv.html#6648" class="Bound">r</a><a id="6690" class="Symbol">))</a> <a id="6693" href="type-former.equiv.html#3389" class="Function Operator">≃ᶠ</a> <a id="6696" href="type-former.equiv.html#6646" class="Bound">A</a><a id="6697" class="Symbol">)</a> <a id="6699" class="Symbol">.</a><a id="6700" href="fibration.transport.html#750" class="Field">vary</a> <a id="6705" class="Symbol">_</a> <a id="6707" class="Symbol">_</a> <a id="6709" href="type-former.equiv.html#6644" class="Bound">σ</a> <a id="6711" href="basic.function.html#279" class="Function">id</a> <a id="6714" href="type-former.equiv.html#6648" class="Bound">r</a> <a id="6716" class="Symbol">(</a><a id="6717" href="type-former.equiv.html#5833" class="Function">idEquivᶠ</a> <a id="6726" href="type-former.equiv.html#6646" class="Bound">A</a> <a id="6728" class="Symbol">(</a><a id="6729" href="axiom.shape.html#1281" class="Postulate Operator">⟪</a> <a id="6731" href="type-former.equiv.html#6644" class="Bound">σ</a> <a id="6733" href="axiom.shape.html#1281" class="Postulate Operator">⟫</a> <a id="6735" href="type-former.equiv.html#6648" class="Bound">r</a><a id="6736" class="Symbol">))</a> <a id="6739" href="type-former.equiv.html#6650" class="Bound">s</a>
    <a id="6745" href="basic.equality.html#1002" class="Function Operator">∙</a> <a id="6747" href="basic.equality.html#1460" class="Function">cong</a>
        <a id="6760" class="Symbol">(</a><a id="6761" href="fibration.transport.html#1963" class="Function">fibTranspStr</a> <a id="6774" class="Symbol">(((</a><a id="6777" href="type-former.equiv.html#6646" class="Bound">A</a> <a id="6779" href="fibration.fibration.html#8733" class="Function Operator">∘ᶠ</a> <a id="6782" href="basic.function.html#339" class="Function">cst</a> <a id="6786" class="Symbol">(</a><a id="6787" href="axiom.shape.html#1281" class="Postulate Operator">⟪</a> <a id="6789" href="type-former.equiv.html#6644" class="Bound">σ</a> <a id="6791" href="axiom.shape.html#1281" class="Postulate Operator">⟫</a> <a id="6793" href="type-former.equiv.html#6648" class="Bound">r</a><a id="6794" class="Symbol">))</a> <a id="6797" href="type-former.equiv.html#3389" class="Function Operator">≃ᶠ</a> <a id="6800" href="type-former.equiv.html#6646" class="Bound">A</a><a id="6801" class="Symbol">)</a> <a id="6803" href="fibration.fibration.html#8733" class="Function Operator">∘ᶠ</a> <a id="6806" href="axiom.shape.html#1281" class="Postulate Operator">⟪</a> <a id="6808" href="type-former.equiv.html#6644" class="Bound">σ</a> <a id="6810" href="axiom.shape.html#1281" class="Postulate Operator">⟫</a><a id="6811" class="Symbol">)</a> <a id="6813" class="Symbol">.</a><a id="6814" href="fibration.transport.html#509" class="Field">lift</a> <a id="6819" href="type-former.equiv.html#6641" class="Bound">S</a> <a id="6821" href="basic.function.html#279" class="Function">id</a> <a id="6824" href="type-former.equiv.html#6648" class="Bound">r</a> <a id="6826" href="basic.function.html#777" class="Function Operator">⦅–⦆</a> <a id="6830" href="type-former.equiv.html#6650" class="Bound">s</a><a id="6831" class="Symbol">)</a>
        <a id="6841" class="Symbol">(</a><a id="6842" href="basic.equality.html#2670" class="Function">cong$</a> <a id="6848" class="Symbol">(</a><a id="6849" href="type-former.equiv.html#5931" class="Function">reindexIdEquivᶠ</a> <a id="6865" href="axiom.shape.html#1281" class="Postulate Operator">⟪</a> <a id="6867" href="type-former.equiv.html#6644" class="Bound">σ</a> <a id="6869" href="axiom.shape.html#1281" class="Postulate Operator">⟫</a><a id="6870" class="Symbol">))</a>
    <a id="6877" href="basic.equality.html#1002" class="Function Operator">∙</a> <a id="6879" href="basic.equality.html#1460" class="Function">cong</a>
        <a id="6892" class="Symbol">(λ</a> <a id="6895" href="type-former.equiv.html#6895" class="Bound">β</a> <a id="6897" class="Symbol">→</a> <a id="6899" href="fibration.transport.html#1963" class="Function">fibTranspStr</a> <a id="6912" class="Symbol">(_</a> <a id="6915" href="type-former.equiv.html#986" class="Function Operator">≃ˣ</a> <a id="6918" class="Symbol">_</a> <a id="6920" href="basic.sigma.html#265" class="InductiveConstructor Operator">,</a> <a id="6922" href="type-former.equiv.html#6895" class="Bound">β</a><a id="6923" class="Symbol">)</a> <a id="6925" class="Symbol">.</a><a id="6926" href="fibration.transport.html#509" class="Field">lift</a> <a id="6931" href="type-former.equiv.html#6641" class="Bound">S</a> <a id="6933" href="basic.function.html#279" class="Function">id</a> <a id="6936" href="type-former.equiv.html#6648" class="Bound">r</a> <a id="6938" class="Symbol">(</a><a id="6939" href="type-former.equiv.html#5833" class="Function">idEquivᶠ</a> <a id="6948" class="Symbol">(</a><a id="6949" href="type-former.equiv.html#6646" class="Bound">A</a> <a id="6951" href="fibration.fibration.html#8733" class="Function Operator">∘ᶠ</a> <a id="6954" href="axiom.shape.html#1281" class="Postulate Operator">⟪</a> <a id="6956" href="type-former.equiv.html#6644" class="Bound">σ</a> <a id="6958" href="axiom.shape.html#1281" class="Postulate Operator">⟫</a><a id="6959" class="Symbol">)</a> <a id="6961" href="type-former.equiv.html#6648" class="Bound">r</a><a id="6962" class="Symbol">)</a> <a id="6964" href="type-former.equiv.html#6650" class="Bound">s</a><a id="6965" class="Symbol">)</a>
        <a id="6975" class="Symbol">(</a><a id="6976" href="basic.sigma.html#990" class="Function">Σeq₂</a> <a id="6981" class="Symbol">(</a><a id="6982" href="type-former.equiv.html#3535" class="Function">reindexEquivᶠ</a> <a id="6996" href="axiom.shape.html#1281" class="Postulate Operator">⟪</a> <a id="6998" href="type-former.equiv.html#6644" class="Bound">σ</a> <a id="7000" href="axiom.shape.html#1281" class="Postulate Operator">⟫</a><a id="7001" class="Symbol">)</a> <a id="7003" href="basic.prelude.html#302" class="InductiveConstructor">refl</a><a id="7007" class="Symbol">)</a>
</pre></body></html>